<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Panda3D: PreparedGraphicsObjects Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Panda3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepanda3d.html">panda3d</a></li><li class="navelem"><a class="el" href="namespacepanda3d_1_1core.html">core</a></li><li class="navelem"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html">PreparedGraphicsObjects</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpanda3d_1_1core_1_1PreparedGraphicsObjects-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PreparedGraphicsObjects Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A table of objects that are saved within the graphics context for reference by handle later. Generally, this represents things like OpenGL texture objects or display lists (or their equivalent on other platforms).  
 <a href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for PreparedGraphicsObjects:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpanda3d_1_1core_1_1PreparedGraphicsObjects.png" usemap="#PreparedGraphicsObjects_map" alt=""/>
  <map id="PreparedGraphicsObjects_map" name="PreparedGraphicsObjects_map">
<area href="classpanda3d_1_1core_1_1ReferenceCount.html" title="A base class for all things that want to be reference-counted. ReferenceCount works in conjunction wi..." alt="ReferenceCount" shape="rect" coords="0,56,159,80"/>
<area href="classpanda3d_1_1core_1_1MemoryBase.html" title="This class is intended to be the base class of all objects in Panda that might be allocated and delet..." alt="MemoryBase" shape="rect" coords="0,0,159,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0372e2cf45504027ede5c3fe74ae0569"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a0372e2cf45504027ede5c3fe74ae0569">dequeueGeom</a> (<a class="el" href="classpanda3d_1_1core_1_1Geom.html">Geom</a> geom)</td></tr>
<tr class="memdesc:a0372e2cf45504027ede5c3fe74ae0569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a geom from the queued list of geoms to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the geom will automatically be dequeued and prepared at the next frame.  <a href="#a0372e2cf45504027ede5c3fe74ae0569">More...</a><br /></td></tr>
<tr class="separator:a0372e2cf45504027ede5c3fe74ae0569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3554e12bc1f350e18cdc463a2406e5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#ac3554e12bc1f350e18cdc463a2406e5d">dequeueIndexBuffer</a> (<a class="el" href="classpanda3d_1_1core_1_1GeomPrimitive.html">GeomPrimitive</a> data)</td></tr>
<tr class="memdesc:ac3554e12bc1f350e18cdc463a2406e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a buffer from the queued list of data arrays to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the data will automatically be dequeued and prepared at the next frame.  <a href="#ac3554e12bc1f350e18cdc463a2406e5d">More...</a><br /></td></tr>
<tr class="separator:ac3554e12bc1f350e18cdc463a2406e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0956505e5c2895960ada9265f22923a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a0956505e5c2895960ada9265f22923a0">dequeueSampler</a> (const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a> sampler)</td></tr>
<tr class="memdesc:a0956505e5c2895960ada9265f22923a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a sampler from the queued list of samplers to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the sampler will automatically be dequeued and prepared at the next frame.  <a href="#a0956505e5c2895960ada9265f22923a0">More...</a><br /></td></tr>
<tr class="separator:a0956505e5c2895960ada9265f22923a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe219d48232827bd07e3227788f5ab4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#abe219d48232827bd07e3227788f5ab4a">dequeueShader</a> (<a class="el" href="classpanda3d_1_1core_1_1Shader.html">Shader</a> shader)</td></tr>
<tr class="memdesc:abe219d48232827bd07e3227788f5ab4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a shader from the queued list of shaders to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the shader will automatically be dequeued and prepared at the next frame.  <a href="#abe219d48232827bd07e3227788f5ab4a">More...</a><br /></td></tr>
<tr class="separator:abe219d48232827bd07e3227788f5ab4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0cb3f7e8347262b3779cb8264c0708"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#ada0cb3f7e8347262b3779cb8264c0708">dequeueTexture</a> (<a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a> tex)</td></tr>
<tr class="memdesc:ada0cb3f7e8347262b3779cb8264c0708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a texture from the queued list of textures to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the texture will automatically be dequeued and prepared at the next frame.  <a href="#ada0cb3f7e8347262b3779cb8264c0708">More...</a><br /></td></tr>
<tr class="separator:ada0cb3f7e8347262b3779cb8264c0708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af837ff4d13ab67d4f96790dc76b1d2f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#af837ff4d13ab67d4f96790dc76b1d2f3">dequeueVertexBuffer</a> (<a class="el" href="classpanda3d_1_1core_1_1GeomVertexArrayData.html">GeomVertexArrayData</a> data)</td></tr>
<tr class="memdesc:af837ff4d13ab67d4f96790dc76b1d2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a buffer from the queued list of data arrays to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the data will automatically be dequeued and prepared at the next frame.  <a href="#af837ff4d13ab67d4f96790dc76b1d2f3">More...</a><br /></td></tr>
<tr class="separator:af837ff4d13ab67d4f96790dc76b1d2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb7b3c146a7627ed59e8908fca2320d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#adfb7b3c146a7627ed59e8908fca2320d">enqueueGeom</a> (<a class="el" href="classpanda3d_1_1core_1_1Geom.html">Geom</a> geom)</td></tr>
<tr class="memdesc:adfb7b3c146a7627ed59e8908fca2320d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a geom would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame).  <a href="#adfb7b3c146a7627ed59e8908fca2320d">More...</a><br /></td></tr>
<tr class="separator:adfb7b3c146a7627ed59e8908fca2320d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3896e684c6052932d15c923e21d1b6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#af3896e684c6052932d15c923e21d1b6d">enqueueIndexBuffer</a> (<a class="el" href="classpanda3d_1_1core_1_1GeomPrimitive.html">GeomPrimitive</a> data)</td></tr>
<tr class="memdesc:af3896e684c6052932d15c923e21d1b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a buffer would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame).  <a href="#af3896e684c6052932d15c923e21d1b6d">More...</a><br /></td></tr>
<tr class="separator:af3896e684c6052932d15c923e21d1b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af429a7316586e2f79e02d6bb03e465"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a0af429a7316586e2f79e02d6bb03e465">enqueueSampler</a> (const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a> sampler)</td></tr>
<tr class="memdesc:a0af429a7316586e2f79e02d6bb03e465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a sampler would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame).  <a href="#a0af429a7316586e2f79e02d6bb03e465">More...</a><br /></td></tr>
<tr class="separator:a0af429a7316586e2f79e02d6bb03e465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8806bf3cd338f5adcb267f9330957d73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a8806bf3cd338f5adcb267f9330957d73">enqueueShader</a> (<a class="el" href="classpanda3d_1_1core_1_1Shader.html">Shader</a> shader)</td></tr>
<tr class="memdesc:a8806bf3cd338f5adcb267f9330957d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a shader would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame).  <a href="#a8806bf3cd338f5adcb267f9330957d73">More...</a><br /></td></tr>
<tr class="separator:a8806bf3cd338f5adcb267f9330957d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf27ea1006799b29ca7f133c23cbbd5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#acf27ea1006799b29ca7f133c23cbbd5b">enqueueTexture</a> (<a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a> tex)</td></tr>
<tr class="memdesc:acf27ea1006799b29ca7f133c23cbbd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a texture would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame).  <a href="#acf27ea1006799b29ca7f133c23cbbd5b">More...</a><br /></td></tr>
<tr class="separator:acf27ea1006799b29ca7f133c23cbbd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d673c4e85915424b573429a1d3378bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a2d673c4e85915424b573429a1d3378bb">enqueueVertexBuffer</a> (<a class="el" href="classpanda3d_1_1core_1_1GeomVertexArrayData.html">GeomVertexArrayData</a> data)</td></tr>
<tr class="memdesc:a2d673c4e85915424b573429a1d3378bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a buffer would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame).  <a href="#a2d673c4e85915424b573429a1d3378bb">More...</a><br /></td></tr>
<tr class="separator:a2d673c4e85915424b573429a1d3378bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdf549236d5be5f2b069cf9208f9a00"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a6bdf549236d5be5f2b069cf9208f9a00">getGraphicsMemoryLimit</a> ()</td></tr>
<tr class="memdesc:a6bdf549236d5be5f2b069cf9208f9a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the artificial cap on graphics memory that will be imposed on this GSG. See set_graphics_memory_limit().  <a href="#a6bdf549236d5be5f2b069cf9208f9a00">More...</a><br /></td></tr>
<tr class="separator:a6bdf549236d5be5f2b069cf9208f9a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848cb7847f1c4c07799cd33dbc153297"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a848cb7847f1c4c07799cd33dbc153297">getName</a> ()</td></tr>
<tr class="memdesc:a848cb7847f1c4c07799cd33dbc153297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the <a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html" title="A table of objects that are saved within the graphics context for reference by handle later...">PreparedGraphicsObjects</a> structure. This is an arbitrary name that serves mainly to uniquify the context for PStats reporting.  <a href="#a848cb7847f1c4c07799cd33dbc153297">More...</a><br /></td></tr>
<tr class="separator:a848cb7847f1c4c07799cd33dbc153297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a87a8767d4e8d8b379f52b0a84c23e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a35a87a8767d4e8d8b379f52b0a84c23e">getNumPrepared</a> ()</td></tr>
<tr class="memdesc:a35a87a8767d4e8d8b379f52b0a84c23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of objects of any kind that have already been prepared on this GSG.  <a href="#a35a87a8767d4e8d8b379f52b0a84c23e">More...</a><br /></td></tr>
<tr class="separator:a35a87a8767d4e8d8b379f52b0a84c23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96189aca0213c5b1b09f0cb3dc27ba6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a96189aca0213c5b1b09f0cb3dc27ba6d">getNumPreparedGeoms</a> ()</td></tr>
<tr class="memdesc:a96189aca0213c5b1b09f0cb3dc27ba6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of geoms that have already been prepared on this GSG.  <a href="#a96189aca0213c5b1b09f0cb3dc27ba6d">More...</a><br /></td></tr>
<tr class="separator:a96189aca0213c5b1b09f0cb3dc27ba6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4da0b5ddfc7d0560dd1e09ecf4835ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#af4da0b5ddfc7d0560dd1e09ecf4835ee">getNumPreparedIndexBuffers</a> ()</td></tr>
<tr class="memdesc:af4da0b5ddfc7d0560dd1e09ecf4835ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of index buffers that have already been prepared on this GSG.  <a href="#af4da0b5ddfc7d0560dd1e09ecf4835ee">More...</a><br /></td></tr>
<tr class="separator:af4da0b5ddfc7d0560dd1e09ecf4835ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74f8b87cf0f479b7740f9f46b127d74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#ae74f8b87cf0f479b7740f9f46b127d74">getNumPreparedSamplers</a> ()</td></tr>
<tr class="memdesc:ae74f8b87cf0f479b7740f9f46b127d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of samplers that have already been prepared on this GSG.  <a href="#ae74f8b87cf0f479b7740f9f46b127d74">More...</a><br /></td></tr>
<tr class="separator:ae74f8b87cf0f479b7740f9f46b127d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65376ba4fd137eee6c2edd48ba75cf96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a65376ba4fd137eee6c2edd48ba75cf96">getNumPreparedShaders</a> ()</td></tr>
<tr class="memdesc:a65376ba4fd137eee6c2edd48ba75cf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of shaders that have already been prepared on this GSG.  <a href="#a65376ba4fd137eee6c2edd48ba75cf96">More...</a><br /></td></tr>
<tr class="separator:a65376ba4fd137eee6c2edd48ba75cf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5232fd4c18d5f32cd2bf66ad0cb99728"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a5232fd4c18d5f32cd2bf66ad0cb99728">getNumPreparedTextures</a> ()</td></tr>
<tr class="memdesc:a5232fd4c18d5f32cd2bf66ad0cb99728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of textures that have already been prepared on this GSG.  <a href="#a5232fd4c18d5f32cd2bf66ad0cb99728">More...</a><br /></td></tr>
<tr class="separator:a5232fd4c18d5f32cd2bf66ad0cb99728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f83071fbb82e34552a9ff78d57edbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a09f83071fbb82e34552a9ff78d57edbe">getNumPreparedVertexBuffers</a> ()</td></tr>
<tr class="memdesc:a09f83071fbb82e34552a9ff78d57edbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertex buffers that have already been prepared on this GSG.  <a href="#a09f83071fbb82e34552a9ff78d57edbe">More...</a><br /></td></tr>
<tr class="separator:a09f83071fbb82e34552a9ff78d57edbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe80311983d673213cf0bf75c41e953"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#afbe80311983d673213cf0bf75c41e953">getNumQueued</a> ()</td></tr>
<tr class="memdesc:afbe80311983d673213cf0bf75c41e953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of objects of any kind that have been enqueued to be prepared on this GSG.  <a href="#afbe80311983d673213cf0bf75c41e953">More...</a><br /></td></tr>
<tr class="separator:afbe80311983d673213cf0bf75c41e953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8074f64167c9e30459b20bc04c7240"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a1b8074f64167c9e30459b20bc04c7240">getNumQueuedGeoms</a> ()</td></tr>
<tr class="memdesc:a1b8074f64167c9e30459b20bc04c7240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of geoms that have been enqueued to be prepared on this GSG.  <a href="#a1b8074f64167c9e30459b20bc04c7240">More...</a><br /></td></tr>
<tr class="separator:a1b8074f64167c9e30459b20bc04c7240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113b96afe352fceef4dba6fae369dc91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a113b96afe352fceef4dba6fae369dc91">getNumQueuedIndexBuffers</a> ()</td></tr>
<tr class="memdesc:a113b96afe352fceef4dba6fae369dc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of index buffers that have been enqueued to be prepared on this GSG.  <a href="#a113b96afe352fceef4dba6fae369dc91">More...</a><br /></td></tr>
<tr class="separator:a113b96afe352fceef4dba6fae369dc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e475e93cede6d762ac6d3bc91815e6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a5e475e93cede6d762ac6d3bc91815e6b">getNumQueuedSamplers</a> ()</td></tr>
<tr class="memdesc:a5e475e93cede6d762ac6d3bc91815e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of samplers that have been enqueued to be prepared on this GSG.  <a href="#a5e475e93cede6d762ac6d3bc91815e6b">More...</a><br /></td></tr>
<tr class="separator:a5e475e93cede6d762ac6d3bc91815e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12220bc5ff62212bee223c97363cd18b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a12220bc5ff62212bee223c97363cd18b">getNumQueuedShaders</a> ()</td></tr>
<tr class="memdesc:a12220bc5ff62212bee223c97363cd18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of shaders that have been enqueued to be prepared on this GSG.  <a href="#a12220bc5ff62212bee223c97363cd18b">More...</a><br /></td></tr>
<tr class="separator:a12220bc5ff62212bee223c97363cd18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbe1dc5c8c5fe5c77e433da7bc46de8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#afcbe1dc5c8c5fe5c77e433da7bc46de8">getNumQueuedTextures</a> ()</td></tr>
<tr class="memdesc:afcbe1dc5c8c5fe5c77e433da7bc46de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of textures that have been enqueued to be prepared on this GSG.  <a href="#afcbe1dc5c8c5fe5c77e433da7bc46de8">More...</a><br /></td></tr>
<tr class="separator:afcbe1dc5c8c5fe5c77e433da7bc46de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa956874ba1d3eccf747fa692c3c73ab4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#aa956874ba1d3eccf747fa692c3c73ab4">getNumQueuedVertexBuffers</a> ()</td></tr>
<tr class="memdesc:aa956874ba1d3eccf747fa692c3c73ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertex buffers that have been enqueued to be prepared on this GSG.  <a href="#aa956874ba1d3eccf747fa692c3c73ab4">More...</a><br /></td></tr>
<tr class="separator:aa956874ba1d3eccf747fa692c3c73ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5954ed07ee1e1ff0d5dce7c38fa7b13d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a5954ed07ee1e1ff0d5dce7c38fa7b13d">isGeomPrepared</a> (const <a class="el" href="classpanda3d_1_1core_1_1Geom.html">Geom</a> geom)</td></tr>
<tr class="memdesc:a5954ed07ee1e1ff0d5dce7c38fa7b13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vertex buffer has been prepared on this GSG, false otherwise.  <a href="#a5954ed07ee1e1ff0d5dce7c38fa7b13d">More...</a><br /></td></tr>
<tr class="separator:a5954ed07ee1e1ff0d5dce7c38fa7b13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292c58d410a7f97b4ff2f78ce6a83f74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a292c58d410a7f97b4ff2f78ce6a83f74">isGeomQueued</a> (const <a class="el" href="classpanda3d_1_1core_1_1Geom.html">Geom</a> geom)</td></tr>
<tr class="memdesc:a292c58d410a7f97b4ff2f78ce6a83f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the geom has been queued on this GSG, false otherwise.  <a href="#a292c58d410a7f97b4ff2f78ce6a83f74">More...</a><br /></td></tr>
<tr class="separator:a292c58d410a7f97b4ff2f78ce6a83f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf102ca6b8ac40184607adfe491f19d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#afdf102ca6b8ac40184607adfe491f19d">isIndexBufferPrepared</a> (const <a class="el" href="classpanda3d_1_1core_1_1GeomPrimitive.html">GeomPrimitive</a> data)</td></tr>
<tr class="memdesc:afdf102ca6b8ac40184607adfe491f19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the index buffer has been prepared on this GSG, false otherwise.  <a href="#afdf102ca6b8ac40184607adfe491f19d">More...</a><br /></td></tr>
<tr class="separator:afdf102ca6b8ac40184607adfe491f19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af182cbe13c3ee2531f00309d6522d75b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#af182cbe13c3ee2531f00309d6522d75b">isIndexBufferQueued</a> (const <a class="el" href="classpanda3d_1_1core_1_1GeomPrimitive.html">GeomPrimitive</a> data)</td></tr>
<tr class="memdesc:af182cbe13c3ee2531f00309d6522d75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the index buffer has been queued on this GSG, false otherwise.  <a href="#af182cbe13c3ee2531f00309d6522d75b">More...</a><br /></td></tr>
<tr class="separator:af182cbe13c3ee2531f00309d6522d75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a51624a7aff7e01ccebc3569581eed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#af2a51624a7aff7e01ccebc3569581eed">isSamplerPrepared</a> (const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a> sampler)</td></tr>
<tr class="memdesc:af2a51624a7aff7e01ccebc3569581eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sampler has been prepared on this GSG, false otherwise.  <a href="#af2a51624a7aff7e01ccebc3569581eed">More...</a><br /></td></tr>
<tr class="separator:af2a51624a7aff7e01ccebc3569581eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4c136111d578c76fd95e27e0a70266"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a1b4c136111d578c76fd95e27e0a70266">isSamplerQueued</a> (const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a> sampler)</td></tr>
<tr class="memdesc:a1b4c136111d578c76fd95e27e0a70266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sampler has been queued on this GSG, false otherwise.  <a href="#a1b4c136111d578c76fd95e27e0a70266">More...</a><br /></td></tr>
<tr class="separator:a1b4c136111d578c76fd95e27e0a70266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e94512f59d754530590fabdf0e3488"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a64e94512f59d754530590fabdf0e3488">isShaderPrepared</a> (const <a class="el" href="classpanda3d_1_1core_1_1Shader.html">Shader</a> shader)</td></tr>
<tr class="memdesc:a64e94512f59d754530590fabdf0e3488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the shader has been prepared on this GSG, false otherwise.  <a href="#a64e94512f59d754530590fabdf0e3488">More...</a><br /></td></tr>
<tr class="separator:a64e94512f59d754530590fabdf0e3488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf8c7f579424cc3132bcfc1ba5bb5f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#acaf8c7f579424cc3132bcfc1ba5bb5f9">isShaderQueued</a> (const <a class="el" href="classpanda3d_1_1core_1_1Shader.html">Shader</a> shader)</td></tr>
<tr class="memdesc:acaf8c7f579424cc3132bcfc1ba5bb5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the shader has been queued on this GSG, false otherwise.  <a href="#acaf8c7f579424cc3132bcfc1ba5bb5f9">More...</a><br /></td></tr>
<tr class="separator:acaf8c7f579424cc3132bcfc1ba5bb5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2663d590b77d8ff3d53bab8c97efcf03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a2663d590b77d8ff3d53bab8c97efcf03">isTexturePrepared</a> (const <a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a> tex)</td></tr>
<tr class="memdesc:a2663d590b77d8ff3d53bab8c97efcf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the texture has been prepared on this GSG, false otherwise.  <a href="#a2663d590b77d8ff3d53bab8c97efcf03">More...</a><br /></td></tr>
<tr class="separator:a2663d590b77d8ff3d53bab8c97efcf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b06ada964fd86a707bc4a5abcd9c67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a29b06ada964fd86a707bc4a5abcd9c67">isTextureQueued</a> (const <a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a> tex)</td></tr>
<tr class="memdesc:a29b06ada964fd86a707bc4a5abcd9c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the texture has been queued on this GSG, false otherwise.  <a href="#a29b06ada964fd86a707bc4a5abcd9c67">More...</a><br /></td></tr>
<tr class="separator:a29b06ada964fd86a707bc4a5abcd9c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb244c0231630e2b898f25eb95009485"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#afb244c0231630e2b898f25eb95009485">isVertexBufferPrepared</a> (const <a class="el" href="classpanda3d_1_1core_1_1GeomVertexArrayData.html">GeomVertexArrayData</a> data)</td></tr>
<tr class="memdesc:afb244c0231630e2b898f25eb95009485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vertex buffer has been prepared on this GSG, false otherwise.  <a href="#afb244c0231630e2b898f25eb95009485">More...</a><br /></td></tr>
<tr class="separator:afb244c0231630e2b898f25eb95009485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34620ae3d85363bc6e94fee90ef09397"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a34620ae3d85363bc6e94fee90ef09397">isVertexBufferQueued</a> (const <a class="el" href="classpanda3d_1_1core_1_1GeomVertexArrayData.html">GeomVertexArrayData</a> data)</td></tr>
<tr class="memdesc:a34620ae3d85363bc6e94fee90ef09397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vertex buffer has been queued on this GSG, false otherwise.  <a href="#a34620ae3d85363bc6e94fee90ef09397">More...</a><br /></td></tr>
<tr class="separator:a34620ae3d85363bc6e94fee90ef09397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad648536c2f04b337cd1d74d2450683e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1GeomContext.html">GeomContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#ad648536c2f04b337cd1d74d2450683e5">prepareGeomNow</a> (<a class="el" href="classpanda3d_1_1core_1_1Geom.html">Geom</a> geom, <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> gsg)</td></tr>
<tr class="memdesc:ad648536c2f04b337cd1d74d2450683e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately creates a new <a class="el" href="classpanda3d_1_1core_1_1GeomContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">GeomContext</a> for the indicated geom and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new geoms. If this is not necessarily the case, you should use enqueue_geom() instead.  <a href="#ad648536c2f04b337cd1d74d2450683e5">More...</a><br /></td></tr>
<tr class="separator:ad648536c2f04b337cd1d74d2450683e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef53ac757e9f50fa27118444161b1d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1IndexBufferContext.html">IndexBufferContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a4ef53ac757e9f50fa27118444161b1d4">prepareIndexBufferNow</a> (<a class="el" href="classpanda3d_1_1core_1_1GeomPrimitive.html">GeomPrimitive</a> data, <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> gsg)</td></tr>
<tr class="memdesc:a4ef53ac757e9f50fa27118444161b1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately creates a new <a class="el" href="classpanda3d_1_1core_1_1IndexBufferContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">IndexBufferContext</a> for the indicated data and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new datas. If this is not necessarily the case, you should use enqueue_index_buffer() instead.  <a href="#a4ef53ac757e9f50fa27118444161b1d4">More...</a><br /></td></tr>
<tr class="separator:a4ef53ac757e9f50fa27118444161b1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3884ce34010f1e796ae73f4bb09da41"><td class="memItemLeft" align="right" valign="top">SamplerContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#ad3884ce34010f1e796ae73f4bb09da41">prepareSamplerNow</a> (const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a> sampler, <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> gsg)</td></tr>
<tr class="memdesc:ad3884ce34010f1e796ae73f4bb09da41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately creates a new SamplerContext for the indicated sampler and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new samplers. If this is not necessarily the case, you should use enqueue_sampler() instead.  <a href="#ad3884ce34010f1e796ae73f4bb09da41">More...</a><br /></td></tr>
<tr class="separator:ad3884ce34010f1e796ae73f4bb09da41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b223690f0359132ff13d7a061ce0a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1ShaderContext.html">ShaderContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a2b223690f0359132ff13d7a061ce0a65">prepareShaderNow</a> (<a class="el" href="classpanda3d_1_1core_1_1Shader.html">Shader</a> shader, <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> gsg)</td></tr>
<tr class="memdesc:a2b223690f0359132ff13d7a061ce0a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately creates a new <a class="el" href="classpanda3d_1_1core_1_1ShaderContext.html">ShaderContext</a> for the indicated shader and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new shaders. If this is not necessarily the case, you should use enqueue_shader() instead.  <a href="#a2b223690f0359132ff13d7a061ce0a65">More...</a><br /></td></tr>
<tr class="separator:a2b223690f0359132ff13d7a061ce0a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b214b39ed88e6b7965a2ed54f411a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1TextureContext.html">TextureContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a51b214b39ed88e6b7965a2ed54f411a7">prepareTextureNow</a> (<a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a> tex, int view, <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> gsg)</td></tr>
<tr class="memdesc:a51b214b39ed88e6b7965a2ed54f411a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately creates a new <a class="el" href="classpanda3d_1_1core_1_1TextureContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">TextureContext</a> for the indicated texture and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new textures. If this is not necessarily the case, you should use enqueue_texture() instead.  <a href="#a51b214b39ed88e6b7965a2ed54f411a7">More...</a><br /></td></tr>
<tr class="separator:a51b214b39ed88e6b7965a2ed54f411a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c960e9254b316091e7892ec5aa1180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1VertexBufferContext.html">VertexBufferContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#ad7c960e9254b316091e7892ec5aa1180">prepareVertexBufferNow</a> (<a class="el" href="classpanda3d_1_1core_1_1GeomVertexArrayData.html">GeomVertexArrayData</a> data, <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> gsg)</td></tr>
<tr class="memdesc:ad7c960e9254b316091e7892ec5aa1180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately creates a new <a class="el" href="classpanda3d_1_1core_1_1VertexBufferContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">VertexBufferContext</a> for the indicated data and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new datas. If this is not necessarily the case, you should use enqueue_vertex_buffer() instead.  <a href="#ad7c960e9254b316091e7892ec5aa1180">More...</a><br /></td></tr>
<tr class="separator:ad7c960e9254b316091e7892ec5aa1180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2f95c36236d16b954e820d44d73727"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a1b2f95c36236d16b954e820d44d73727">releaseAll</a> ()</td></tr>
<tr class="memdesc:a1b2f95c36236d16b954e820d44d73727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all prepared objects of all kinds at once.  <a href="#a1b2f95c36236d16b954e820d44d73727">More...</a><br /></td></tr>
<tr class="separator:a1b2f95c36236d16b954e820d44d73727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcfb89c7a8ee60d667287c3bfa4481e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a0fcfb89c7a8ee60d667287c3bfa4481e">releaseAllGeoms</a> ()</td></tr>
<tr class="memdesc:a0fcfb89c7a8ee60d667287c3bfa4481e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all geoms at once. This will force them to be reloaded into geom memory for all GSG's that share this object. Returns the number of geoms released.  <a href="#a0fcfb89c7a8ee60d667287c3bfa4481e">More...</a><br /></td></tr>
<tr class="separator:a0fcfb89c7a8ee60d667287c3bfa4481e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccf5ba475ac324ede2f69b0280e68ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#adccf5ba475ac324ede2f69b0280e68ae">releaseAllIndexBuffers</a> ()</td></tr>
<tr class="memdesc:adccf5ba475ac324ede2f69b0280e68ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all datas at once. This will force them to be reloaded into data memory for all GSG's that share this object. Returns the number of datas released.  <a href="#adccf5ba475ac324ede2f69b0280e68ae">More...</a><br /></td></tr>
<tr class="separator:adccf5ba475ac324ede2f69b0280e68ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e99145bcfa3cda04cc79a28a1d7cc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#ac0e99145bcfa3cda04cc79a28a1d7cc0">releaseAllSamplers</a> ()</td></tr>
<tr class="memdesc:ac0e99145bcfa3cda04cc79a28a1d7cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all samplers at once. This will force them to be reloaded for all GSG's that share this object. Returns the number of samplers released.  <a href="#ac0e99145bcfa3cda04cc79a28a1d7cc0">More...</a><br /></td></tr>
<tr class="separator:ac0e99145bcfa3cda04cc79a28a1d7cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf33829fba1763cc5ce3a95ea51b2a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a4bf33829fba1763cc5ce3a95ea51b2a1">releaseAllShaders</a> ()</td></tr>
<tr class="memdesc:a4bf33829fba1763cc5ce3a95ea51b2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all shaders at once. This will force them to be reloaded into shader memory for all GSG's that share this object. Returns the number of shaders released.  <a href="#a4bf33829fba1763cc5ce3a95ea51b2a1">More...</a><br /></td></tr>
<tr class="separator:a4bf33829fba1763cc5ce3a95ea51b2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11dec930099f4cdbf1c4875a4b9f4a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#af11dec930099f4cdbf1c4875a4b9f4a8">releaseAllTextures</a> ()</td></tr>
<tr class="memdesc:af11dec930099f4cdbf1c4875a4b9f4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all textures at once. This will force them to be reloaded into texture memory for all GSG's that share this object. Returns the number of textures released.  <a href="#af11dec930099f4cdbf1c4875a4b9f4a8">More...</a><br /></td></tr>
<tr class="separator:af11dec930099f4cdbf1c4875a4b9f4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9095923ffe7555f79b4c8d026fa58d28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a9095923ffe7555f79b4c8d026fa58d28">releaseAllVertexBuffers</a> ()</td></tr>
<tr class="memdesc:a9095923ffe7555f79b4c8d026fa58d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all datas at once. This will force them to be reloaded into data memory for all GSG's that share this object. Returns the number of datas released.  <a href="#a9095923ffe7555f79b4c8d026fa58d28">More...</a><br /></td></tr>
<tr class="separator:a9095923ffe7555f79b4c8d026fa58d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9162fe52c8b20631d06ef899c5fefd22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a9162fe52c8b20631d06ef899c5fefd22">releaseGeom</a> (<a class="el" href="classpanda3d_1_1core_1_1GeomContext.html">GeomContext</a> gc)</td></tr>
<tr class="memdesc:a9162fe52c8b20631d06ef899c5fefd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a geom context, created by a previous call to prepare_geom(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release geoms&ndash;this prevents conflicts from threading or multiple GSG's sharing geoms (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_geom is called).  <a href="#a9162fe52c8b20631d06ef899c5fefd22">More...</a><br /></td></tr>
<tr class="separator:a9162fe52c8b20631d06ef899c5fefd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc7ffd4d78ab95961a83b55a35aaea3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a8bc7ffd4d78ab95961a83b55a35aaea3">releaseIndexBuffer</a> (<a class="el" href="classpanda3d_1_1core_1_1IndexBufferContext.html">IndexBufferContext</a> ibc)</td></tr>
<tr class="memdesc:a8bc7ffd4d78ab95961a83b55a35aaea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a data context, created by a previous call to prepare_index_buffer(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release datas&ndash;this prevents conflicts from threading or multiple GSG's sharing datas (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_index_buffer is called).  <a href="#a8bc7ffd4d78ab95961a83b55a35aaea3">More...</a><br /></td></tr>
<tr class="separator:a8bc7ffd4d78ab95961a83b55a35aaea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622ee1b6f470219bac72a5d14c33af62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a622ee1b6f470219bac72a5d14c33af62">releaseSampler</a> (SamplerContext sc)</td></tr>
<tr class="memdesc:a622ee1b6f470219bac72a5d14c33af62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a sampler context, created by a previous call to prepare_sampler(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release samplers.  <a href="#a622ee1b6f470219bac72a5d14c33af62">More...</a><br /></td></tr>
<tr class="separator:a622ee1b6f470219bac72a5d14c33af62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eb8eafd0a9697708cf488c58a0ac7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a35eb8eafd0a9697708cf488c58a0ac7c">releaseSampler</a> (const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a> sampler)</td></tr>
<tr class="memdesc:a35eb8eafd0a9697708cf488c58a0ac7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a sampler if it has already been prepared, or removes it from the preparation queue.  <a href="#a35eb8eafd0a9697708cf488c58a0ac7c">More...</a><br /></td></tr>
<tr class="separator:a35eb8eafd0a9697708cf488c58a0ac7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad340cddaeead7c6561a87e1bbf4af291"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#ad340cddaeead7c6561a87e1bbf4af291">releaseShader</a> (<a class="el" href="classpanda3d_1_1core_1_1ShaderContext.html">ShaderContext</a> sc)</td></tr>
<tr class="memdesc:ad340cddaeead7c6561a87e1bbf4af291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a shader context, created by a previous call to prepare_shader(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release shaders&ndash;this prevents conflicts from threading or multiple GSG's sharing shaders (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_shader is called).  <a href="#ad340cddaeead7c6561a87e1bbf4af291">More...</a><br /></td></tr>
<tr class="separator:ad340cddaeead7c6561a87e1bbf4af291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ed8f546386edf122f0ca3d6f9d65db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a76ed8f546386edf122f0ca3d6f9d65db">releaseTexture</a> (<a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a> tex)</td></tr>
<tr class="memdesc:a76ed8f546386edf122f0ca3d6f9d65db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a texture if it has already been prepared, or removes it from the preparation queue.  <a href="#a76ed8f546386edf122f0ca3d6f9d65db">More...</a><br /></td></tr>
<tr class="separator:a76ed8f546386edf122f0ca3d6f9d65db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dca0881d38745fca4182d95f067d24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a13dca0881d38745fca4182d95f067d24">releaseTexture</a> (<a class="el" href="classpanda3d_1_1core_1_1TextureContext.html">TextureContext</a> tc)</td></tr>
<tr class="memdesc:a13dca0881d38745fca4182d95f067d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a texture context, created by a previous call to prepare_texture(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release textures&ndash;this prevents conflicts from threading or multiple GSG's sharing textures (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_texture is called).  <a href="#a13dca0881d38745fca4182d95f067d24">More...</a><br /></td></tr>
<tr class="separator:a13dca0881d38745fca4182d95f067d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938e6bb53d88a6de38db9bd8564de7e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a938e6bb53d88a6de38db9bd8564de7e2">releaseVertexBuffer</a> (<a class="el" href="classpanda3d_1_1core_1_1VertexBufferContext.html">VertexBufferContext</a> vbc)</td></tr>
<tr class="memdesc:a938e6bb53d88a6de38db9bd8564de7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a data context, created by a previous call to prepare_vertex_buffer(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release datas&ndash;this prevents conflicts from threading or multiple GSG's sharing datas (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_vertex_buffer is called).  <a href="#a938e6bb53d88a6de38db9bd8564de7e2">More...</a><br /></td></tr>
<tr class="separator:a938e6bb53d88a6de38db9bd8564de7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32d5317df9a26b3fb353ad0086eb6b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#ab32d5317df9a26b3fb353ad0086eb6b1">setGraphicsMemoryLimit</a> (size_t limit)</td></tr>
<tr class="memdesc:ab32d5317df9a26b3fb353ad0086eb6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an artificial cap on graphics memory that will be imposed on this GSG.  <a href="#ab32d5317df9a26b3fb353ad0086eb6b1">More...</a><br /></td></tr>
<tr class="separator:ab32d5317df9a26b3fb353ad0086eb6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983b4d7358455ec69b18806d8564a8d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a983b4d7358455ec69b18806d8564a8d9">showGraphicsMemoryLru</a> (<a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a> out)</td></tr>
<tr class="memdesc:a983b4d7358455ec69b18806d8564a8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to the indicated ostream a report of how the various textures and vertex buffers are allocated in the LRU.  <a href="#a983b4d7358455ec69b18806d8564a8d9">More...</a><br /></td></tr>
<tr class="separator:a983b4d7358455ec69b18806d8564a8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be3aa151abb068ab6404c5598adafc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html#a9be3aa151abb068ab6404c5598adafc1">showResidencyTrackers</a> (<a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a> out)</td></tr>
<tr class="memdesc:a9be3aa151abb068ab6404c5598adafc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to the indicated ostream a report of how the various textures and vertex buffers are allocated in the LRU.  <a href="#a9be3aa151abb068ab6404c5598adafc1">More...</a><br /></td></tr>
<tr class="separator:a9be3aa151abb068ab6404c5598adafc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpanda3d_1_1core_1_1ReferenceCount')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a6c336617bdadf1660f079d3ceacf48bf">getRefCount</a> ()</td></tr>
<tr class="memdesc:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current reference count.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a6c336617bdadf1660f079d3ceacf48bf">More...</a><br /></td></tr>
<tr class="separator:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a895fd31ef3cb5add22a875fc9e5bee19">ref</a> ()</td></tr>
<tr class="memdesc:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly increments the reference count. User code should avoid using <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a895fd31ef3cb5add22a875fc9e5bee19" title="Explicitly increments the reference count. User code should avoid using ref() and unref() directly...">ref()</a> and <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02" title="Explicitly decrements the reference count. Note that the object will not be implicitly deleted by unr...">unref()</a> directly, which can result in missed reference counts. Instead, let a PointerTo object manage the reference counting automatically.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a895fd31ef3cb5add22a875fc9e5bee19">More...</a><br /></td></tr>
<tr class="separator:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a8d4e39df87bae0b1121681eb5e725812">testRefCountIntegrity</a> ()</td></tr>
<tr class="memdesc:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some easy checks to make sure that the reference count isn't completely bogus. Returns true if ok, false otherwise.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a8d4e39df87bae0b1121681eb5e725812">More...</a><br /></td></tr>
<tr class="separator:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a70436632764926b0453751c516623065">testRefCountNonzero</a> ()</td></tr>
<tr class="memdesc:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some easy checks to make sure that the reference count isn't zero, or completely bogus. Returns true if ok, false otherwise.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a70436632764926b0453751c516623065">More...</a><br /></td></tr>
<tr class="separator:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02">unref</a> ()</td></tr>
<tr class="memdesc:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly decrements the reference count. Note that the object will not be implicitly deleted by <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02" title="Explicitly decrements the reference count. Note that the object will not be implicitly deleted by unr...">unref()</a> simply because the reference count drops to zero. (Having a member function delete itself is problematic.) However, see the helper function unref_delete().  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02">More...</a><br /></td></tr>
<tr class="separator:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a6ee74ed0904ab08032e044c5bea991dc">getClassType</a> ()</td></tr>
<tr class="separator:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A table of objects that are saved within the graphics context for reference by handle later. Generally, this represents things like OpenGL texture objects or display lists (or their equivalent on other platforms). </p>
<p>This object simply records the pointers to the context objects created by the individual GSG's; these context objects will contain enough information to reference or release the actual object stored within the graphics context.</p>
<p>These tables may potentially be shared between related graphics contexts, hence their storage here in a separate object rather than as a part of the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0372e2cf45504027ede5c3fe74ae0569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0372e2cf45504027ede5c3fe74ae0569">&#9670;&nbsp;</a></span>dequeueGeom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dequeueGeom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Geom.html">Geom</a>&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a geom from the queued list of geoms to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the geom will automatically be dequeued and prepared at the next frame. </p>
<p>The return value is true if the geom is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="ac3554e12bc1f350e18cdc463a2406e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3554e12bc1f350e18cdc463a2406e5d">&#9670;&nbsp;</a></span>dequeueIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dequeueIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GeomPrimitive.html">GeomPrimitive</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a buffer from the queued list of data arrays to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the data will automatically be dequeued and prepared at the next frame. </p>
<p>The return value is true if the buffer is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="a0956505e5c2895960ada9265f22923a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0956505e5c2895960ada9265f22923a0">&#9670;&nbsp;</a></span>dequeueSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dequeueSampler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a>&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a sampler from the queued list of samplers to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the sampler will automatically be dequeued and prepared at the next frame. </p>
<p>The return value is true if the sampler is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="abe219d48232827bd07e3227788f5ab4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe219d48232827bd07e3227788f5ab4a">&#9670;&nbsp;</a></span>dequeueShader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dequeueShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Shader.html">Shader</a>&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a shader from the queued list of shaders to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the shader will automatically be dequeued and prepared at the next frame. </p>
<p>The return value is true if the shader is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="ada0cb3f7e8347262b3779cb8264c0708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0cb3f7e8347262b3779cb8264c0708">&#9670;&nbsp;</a></span>dequeueTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dequeueTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a>&#160;</td>
          <td class="paramname"><em>tex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a texture from the queued list of textures to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the texture will automatically be dequeued and prepared at the next frame. </p>
<p>The return value is true if the texture is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="af837ff4d13ab67d4f96790dc76b1d2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af837ff4d13ab67d4f96790dc76b1d2f3">&#9670;&nbsp;</a></span>dequeueVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dequeueVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GeomVertexArrayData.html">GeomVertexArrayData</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a buffer from the queued list of data arrays to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the data will automatically be dequeued and prepared at the next frame. </p>
<p>The return value is true if the buffer is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="adfb7b3c146a7627ed59e8908fca2320d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb7b3c146a7627ed59e8908fca2320d">&#9670;&nbsp;</a></span>enqueueGeom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enqueueGeom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Geom.html">Geom</a>&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a geom would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="af3896e684c6052932d15c923e21d1b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3896e684c6052932d15c923e21d1b6d">&#9670;&nbsp;</a></span>enqueueIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enqueueIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GeomPrimitive.html">GeomPrimitive</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a buffer would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="a0af429a7316586e2f79e02d6bb03e465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af429a7316586e2f79e02d6bb03e465">&#9670;&nbsp;</a></span>enqueueSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enqueueSampler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a>&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a sampler would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="a8806bf3cd338f5adcb267f9330957d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8806bf3cd338f5adcb267f9330957d73">&#9670;&nbsp;</a></span>enqueueShader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enqueueShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Shader.html">Shader</a>&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a shader would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="acf27ea1006799b29ca7f133c23cbbd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf27ea1006799b29ca7f133c23cbbd5b">&#9670;&nbsp;</a></span>enqueueTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enqueueTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a>&#160;</td>
          <td class="paramname"><em>tex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a texture would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="a2d673c4e85915424b573429a1d3378bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d673c4e85915424b573429a1d3378bb">&#9670;&nbsp;</a></span>enqueueVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enqueueVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GeomVertexArrayData.html">GeomVertexArrayData</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a buffer would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="a6bdf549236d5be5f2b069cf9208f9a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdf549236d5be5f2b069cf9208f9a00">&#9670;&nbsp;</a></span>getGraphicsMemoryLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getGraphicsMemoryLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the artificial cap on graphics memory that will be imposed on this GSG. See set_graphics_memory_limit(). </p>

</div>
</div>
<a id="a848cb7847f1c4c07799cd33dbc153297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848cb7847f1c4c07799cd33dbc153297">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the <a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html" title="A table of objects that are saved within the graphics context for reference by handle later...">PreparedGraphicsObjects</a> structure. This is an arbitrary name that serves mainly to uniquify the context for PStats reporting. </p>

</div>
</div>
<a id="a35a87a8767d4e8d8b379f52b0a84c23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a87a8767d4e8d8b379f52b0a84c23e">&#9670;&nbsp;</a></span>getNumPrepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumPrepared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of objects of any kind that have already been prepared on this GSG. </p>

</div>
</div>
<a id="a96189aca0213c5b1b09f0cb3dc27ba6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96189aca0213c5b1b09f0cb3dc27ba6d">&#9670;&nbsp;</a></span>getNumPreparedGeoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumPreparedGeoms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of geoms that have already been prepared on this GSG. </p>

</div>
</div>
<a id="af4da0b5ddfc7d0560dd1e09ecf4835ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4da0b5ddfc7d0560dd1e09ecf4835ee">&#9670;&nbsp;</a></span>getNumPreparedIndexBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumPreparedIndexBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of index buffers that have already been prepared on this GSG. </p>

</div>
</div>
<a id="ae74f8b87cf0f479b7740f9f46b127d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74f8b87cf0f479b7740f9f46b127d74">&#9670;&nbsp;</a></span>getNumPreparedSamplers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumPreparedSamplers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of samplers that have already been prepared on this GSG. </p>

</div>
</div>
<a id="a65376ba4fd137eee6c2edd48ba75cf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65376ba4fd137eee6c2edd48ba75cf96">&#9670;&nbsp;</a></span>getNumPreparedShaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumPreparedShaders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of shaders that have already been prepared on this GSG. </p>

</div>
</div>
<a id="a5232fd4c18d5f32cd2bf66ad0cb99728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5232fd4c18d5f32cd2bf66ad0cb99728">&#9670;&nbsp;</a></span>getNumPreparedTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumPreparedTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of textures that have already been prepared on this GSG. </p>

</div>
</div>
<a id="a09f83071fbb82e34552a9ff78d57edbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f83071fbb82e34552a9ff78d57edbe">&#9670;&nbsp;</a></span>getNumPreparedVertexBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumPreparedVertexBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of vertex buffers that have already been prepared on this GSG. </p>

</div>
</div>
<a id="afbe80311983d673213cf0bf75c41e953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe80311983d673213cf0bf75c41e953">&#9670;&nbsp;</a></span>getNumQueued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumQueued </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of objects of any kind that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="a1b8074f64167c9e30459b20bc04c7240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8074f64167c9e30459b20bc04c7240">&#9670;&nbsp;</a></span>getNumQueuedGeoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumQueuedGeoms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of geoms that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="a113b96afe352fceef4dba6fae369dc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113b96afe352fceef4dba6fae369dc91">&#9670;&nbsp;</a></span>getNumQueuedIndexBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumQueuedIndexBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of index buffers that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="a5e475e93cede6d762ac6d3bc91815e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e475e93cede6d762ac6d3bc91815e6b">&#9670;&nbsp;</a></span>getNumQueuedSamplers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumQueuedSamplers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of samplers that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="a12220bc5ff62212bee223c97363cd18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12220bc5ff62212bee223c97363cd18b">&#9670;&nbsp;</a></span>getNumQueuedShaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumQueuedShaders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of shaders that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="afcbe1dc5c8c5fe5c77e433da7bc46de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbe1dc5c8c5fe5c77e433da7bc46de8">&#9670;&nbsp;</a></span>getNumQueuedTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumQueuedTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of textures that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="aa956874ba1d3eccf747fa692c3c73ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa956874ba1d3eccf747fa692c3c73ab4">&#9670;&nbsp;</a></span>getNumQueuedVertexBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumQueuedVertexBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of vertex buffers that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="a5954ed07ee1e1ff0d5dce7c38fa7b13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5954ed07ee1e1ff0d5dce7c38fa7b13d">&#9670;&nbsp;</a></span>isGeomPrepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isGeomPrepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Geom.html">Geom</a>&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the vertex buffer has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="a292c58d410a7f97b4ff2f78ce6a83f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292c58d410a7f97b4ff2f78ce6a83f74">&#9670;&nbsp;</a></span>isGeomQueued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isGeomQueued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Geom.html">Geom</a>&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the geom has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="afdf102ca6b8ac40184607adfe491f19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf102ca6b8ac40184607adfe491f19d">&#9670;&nbsp;</a></span>isIndexBufferPrepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isIndexBufferPrepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1GeomPrimitive.html">GeomPrimitive</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the index buffer has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="af182cbe13c3ee2531f00309d6522d75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af182cbe13c3ee2531f00309d6522d75b">&#9670;&nbsp;</a></span>isIndexBufferQueued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isIndexBufferQueued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1GeomPrimitive.html">GeomPrimitive</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the index buffer has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="af2a51624a7aff7e01ccebc3569581eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a51624a7aff7e01ccebc3569581eed">&#9670;&nbsp;</a></span>isSamplerPrepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSamplerPrepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a>&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the sampler has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="a1b4c136111d578c76fd95e27e0a70266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4c136111d578c76fd95e27e0a70266">&#9670;&nbsp;</a></span>isSamplerQueued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSamplerQueued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a>&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the sampler has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="a64e94512f59d754530590fabdf0e3488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e94512f59d754530590fabdf0e3488">&#9670;&nbsp;</a></span>isShaderPrepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isShaderPrepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Shader.html">Shader</a>&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the shader has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="acaf8c7f579424cc3132bcfc1ba5bb5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf8c7f579424cc3132bcfc1ba5bb5f9">&#9670;&nbsp;</a></span>isShaderQueued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isShaderQueued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Shader.html">Shader</a>&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the shader has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="a2663d590b77d8ff3d53bab8c97efcf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2663d590b77d8ff3d53bab8c97efcf03">&#9670;&nbsp;</a></span>isTexturePrepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isTexturePrepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a>&#160;</td>
          <td class="paramname"><em>tex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the texture has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="a29b06ada964fd86a707bc4a5abcd9c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b06ada964fd86a707bc4a5abcd9c67">&#9670;&nbsp;</a></span>isTextureQueued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isTextureQueued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a>&#160;</td>
          <td class="paramname"><em>tex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the texture has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="afb244c0231630e2b898f25eb95009485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb244c0231630e2b898f25eb95009485">&#9670;&nbsp;</a></span>isVertexBufferPrepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isVertexBufferPrepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1GeomVertexArrayData.html">GeomVertexArrayData</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the vertex buffer has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="a34620ae3d85363bc6e94fee90ef09397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34620ae3d85363bc6e94fee90ef09397">&#9670;&nbsp;</a></span>isVertexBufferQueued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isVertexBufferQueued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1GeomVertexArrayData.html">GeomVertexArrayData</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the vertex buffer has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="ad648536c2f04b337cd1d74d2450683e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad648536c2f04b337cd1d74d2450683e5">&#9670;&nbsp;</a></span>prepareGeomNow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1GeomContext.html">GeomContext</a> prepareGeomNow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Geom.html">Geom</a>&#160;</td>
          <td class="paramname"><em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a>&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Immediately creates a new <a class="el" href="classpanda3d_1_1core_1_1GeomContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">GeomContext</a> for the indicated geom and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new geoms. If this is not necessarily the case, you should use enqueue_geom() instead. </p>
<p>Normally, this function is not called directly. Call Geom::prepare_now() instead.</p>
<p>The <a class="el" href="classpanda3d_1_1core_1_1GeomContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">GeomContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular geom, and will exist as long as the geom is ready to be rendered.</p>
<p>When either the <a class="el" href="classpanda3d_1_1core_1_1Geom.html" title="A container for geometry primitives. This class associates one or more GeomPrimitive objects with a t...">Geom</a> or the <a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html" title="A table of objects that are saved within the graphics context for reference by handle later...">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classpanda3d_1_1core_1_1GeomContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">GeomContext</a> will be deleted. </p>

</div>
</div>
<a id="a4ef53ac757e9f50fa27118444161b1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef53ac757e9f50fa27118444161b1d4">&#9670;&nbsp;</a></span>prepareIndexBufferNow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1IndexBufferContext.html">IndexBufferContext</a> prepareIndexBufferNow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GeomPrimitive.html">GeomPrimitive</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a>&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Immediately creates a new <a class="el" href="classpanda3d_1_1core_1_1IndexBufferContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">IndexBufferContext</a> for the indicated data and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new datas. If this is not necessarily the case, you should use enqueue_index_buffer() instead. </p>
<p>Normally, this function is not called directly. Call Data::prepare_now() instead.</p>
<p>The <a class="el" href="classpanda3d_1_1core_1_1IndexBufferContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">IndexBufferContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular data, and will exist as long as the data is ready to be rendered.</p>
<p>When either the Data or the <a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html" title="A table of objects that are saved within the graphics context for reference by handle later...">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classpanda3d_1_1core_1_1IndexBufferContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">IndexBufferContext</a> will be deleted. </p>

</div>
</div>
<a id="ad3884ce34010f1e796ae73f4bb09da41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3884ce34010f1e796ae73f4bb09da41">&#9670;&nbsp;</a></span>prepareSamplerNow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SamplerContext prepareSamplerNow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a>&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a>&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Immediately creates a new SamplerContext for the indicated sampler and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new samplers. If this is not necessarily the case, you should use enqueue_sampler() instead. </p>
<p>Normally, this function is not called directly. Call Sampler::prepare_now() instead.</p>
<p>The SamplerContext contains all of the pertinent information needed by the GSG to keep track of this one particular sampler, and will exist as long as the sampler is ready to be rendered.</p>
<p>When either the Sampler or the <a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html" title="A table of objects that are saved within the graphics context for reference by handle later...">PreparedGraphicsObjects</a> object destructs, the SamplerContext will be deleted. </p>

</div>
</div>
<a id="a2b223690f0359132ff13d7a061ce0a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b223690f0359132ff13d7a061ce0a65">&#9670;&nbsp;</a></span>prepareShaderNow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1ShaderContext.html">ShaderContext</a> prepareShaderNow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Shader.html">Shader</a>&#160;</td>
          <td class="paramname"><em>shader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a>&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Immediately creates a new <a class="el" href="classpanda3d_1_1core_1_1ShaderContext.html">ShaderContext</a> for the indicated shader and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new shaders. If this is not necessarily the case, you should use enqueue_shader() instead. </p>
<p>Normally, this function is not called directly. Call Shader::prepare_now() instead.</p>
<p>The <a class="el" href="classpanda3d_1_1core_1_1ShaderContext.html">ShaderContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular shader, and will exist as long as the shader is ready to be rendered.</p>
<p>When either the <a class="el" href="classpanda3d_1_1core_1_1Shader.html" title="Summary: The Shader class is meant to select the Shader Language, select the available profile...">Shader</a> or the <a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html" title="A table of objects that are saved within the graphics context for reference by handle later...">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classpanda3d_1_1core_1_1ShaderContext.html">ShaderContext</a> will be deleted. </p>

</div>
</div>
<a id="a51b214b39ed88e6b7965a2ed54f411a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b214b39ed88e6b7965a2ed54f411a7">&#9670;&nbsp;</a></span>prepareTextureNow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1TextureContext.html">TextureContext</a> prepareTextureNow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a>&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a>&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Immediately creates a new <a class="el" href="classpanda3d_1_1core_1_1TextureContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">TextureContext</a> for the indicated texture and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new textures. If this is not necessarily the case, you should use enqueue_texture() instead. </p>
<p>Normally, this function is not called directly. Call Texture::prepare_now() instead.</p>
<p>The <a class="el" href="classpanda3d_1_1core_1_1TextureContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">TextureContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular texture, and will exist as long as the texture is ready to be rendered.</p>
<p>When either the <a class="el" href="classpanda3d_1_1core_1_1Texture.html" title="Represents a texture object, which is typically a single 2-d image but may also represent a 1-d or 3-...">Texture</a> or the <a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html" title="A table of objects that are saved within the graphics context for reference by handle later...">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classpanda3d_1_1core_1_1TextureContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">TextureContext</a> will be deleted. </p>

</div>
</div>
<a id="ad7c960e9254b316091e7892ec5aa1180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c960e9254b316091e7892ec5aa1180">&#9670;&nbsp;</a></span>prepareVertexBufferNow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1VertexBufferContext.html">VertexBufferContext</a> prepareVertexBufferNow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GeomVertexArrayData.html">GeomVertexArrayData</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a>&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Immediately creates a new <a class="el" href="classpanda3d_1_1core_1_1VertexBufferContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">VertexBufferContext</a> for the indicated data and returns it. This assumes that the <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new datas. If this is not necessarily the case, you should use enqueue_vertex_buffer() instead. </p>
<p>Normally, this function is not called directly. Call Data::prepare_now() instead.</p>
<p>The <a class="el" href="classpanda3d_1_1core_1_1VertexBufferContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">VertexBufferContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular data, and will exist as long as the data is ready to be rendered.</p>
<p>When either the Data or the <a class="el" href="classpanda3d_1_1core_1_1PreparedGraphicsObjects.html" title="A table of objects that are saved within the graphics context for reference by handle later...">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classpanda3d_1_1core_1_1VertexBufferContext.html" title="This is a special class object that holds all the information returned by a particular GSG to indicat...">VertexBufferContext</a> will be deleted. </p>

</div>
</div>
<a id="a1b2f95c36236d16b954e820d44d73727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2f95c36236d16b954e820d44d73727">&#9670;&nbsp;</a></span>releaseAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">releaseAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases all prepared objects of all kinds at once. </p>

</div>
</div>
<a id="a0fcfb89c7a8ee60d667287c3bfa4481e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcfb89c7a8ee60d667287c3bfa4481e">&#9670;&nbsp;</a></span>releaseAllGeoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int releaseAllGeoms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases all geoms at once. This will force them to be reloaded into geom memory for all GSG's that share this object. Returns the number of geoms released. </p>

</div>
</div>
<a id="adccf5ba475ac324ede2f69b0280e68ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccf5ba475ac324ede2f69b0280e68ae">&#9670;&nbsp;</a></span>releaseAllIndexBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int releaseAllIndexBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases all datas at once. This will force them to be reloaded into data memory for all GSG's that share this object. Returns the number of datas released. </p>

</div>
</div>
<a id="ac0e99145bcfa3cda04cc79a28a1d7cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e99145bcfa3cda04cc79a28a1d7cc0">&#9670;&nbsp;</a></span>releaseAllSamplers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int releaseAllSamplers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases all samplers at once. This will force them to be reloaded for all GSG's that share this object. Returns the number of samplers released. </p>

</div>
</div>
<a id="a4bf33829fba1763cc5ce3a95ea51b2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf33829fba1763cc5ce3a95ea51b2a1">&#9670;&nbsp;</a></span>releaseAllShaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int releaseAllShaders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases all shaders at once. This will force them to be reloaded into shader memory for all GSG's that share this object. Returns the number of shaders released. </p>

</div>
</div>
<a id="af11dec930099f4cdbf1c4875a4b9f4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11dec930099f4cdbf1c4875a4b9f4a8">&#9670;&nbsp;</a></span>releaseAllTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int releaseAllTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases all textures at once. This will force them to be reloaded into texture memory for all GSG's that share this object. Returns the number of textures released. </p>

</div>
</div>
<a id="a9095923ffe7555f79b4c8d026fa58d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9095923ffe7555f79b4c8d026fa58d28">&#9670;&nbsp;</a></span>releaseAllVertexBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int releaseAllVertexBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases all datas at once. This will force them to be reloaded into data memory for all GSG's that share this object. Returns the number of datas released. </p>

</div>
</div>
<a id="a9162fe52c8b20631d06ef899c5fefd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9162fe52c8b20631d06ef899c5fefd22">&#9670;&nbsp;</a></span>releaseGeom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">releaseGeom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GeomContext.html">GeomContext</a>&#160;</td>
          <td class="paramname"><em>gc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a geom context, created by a previous call to prepare_geom(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release geoms&ndash;this prevents conflicts from threading or multiple GSG's sharing geoms (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_geom is called). </p>

</div>
</div>
<a id="a8bc7ffd4d78ab95961a83b55a35aaea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc7ffd4d78ab95961a83b55a35aaea3">&#9670;&nbsp;</a></span>releaseIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">releaseIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1IndexBufferContext.html">IndexBufferContext</a>&#160;</td>
          <td class="paramname"><em>ibc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a data context, created by a previous call to prepare_index_buffer(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release datas&ndash;this prevents conflicts from threading or multiple GSG's sharing datas (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_index_buffer is called). </p>

</div>
</div>
<a id="a622ee1b6f470219bac72a5d14c33af62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622ee1b6f470219bac72a5d14c33af62">&#9670;&nbsp;</a></span>releaseSampler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">releaseSampler </td>
          <td>(</td>
          <td class="paramtype">SamplerContext&#160;</td>
          <td class="paramname"><em>sc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a sampler context, created by a previous call to prepare_sampler(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release samplers. </p>

</div>
</div>
<a id="a35eb8eafd0a9697708cf488c58a0ac7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35eb8eafd0a9697708cf488c58a0ac7c">&#9670;&nbsp;</a></span>releaseSampler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">releaseSampler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1SamplerState.html">SamplerState</a>&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a sampler if it has already been prepared, or removes it from the preparation queue. </p>

</div>
</div>
<a id="ad340cddaeead7c6561a87e1bbf4af291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad340cddaeead7c6561a87e1bbf4af291">&#9670;&nbsp;</a></span>releaseShader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">releaseShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1ShaderContext.html">ShaderContext</a>&#160;</td>
          <td class="paramname"><em>sc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a shader context, created by a previous call to prepare_shader(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release shaders&ndash;this prevents conflicts from threading or multiple GSG's sharing shaders (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_shader is called). </p>

</div>
</div>
<a id="a76ed8f546386edf122f0ca3d6f9d65db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ed8f546386edf122f0ca3d6f9d65db">&#9670;&nbsp;</a></span>releaseTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">releaseTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a>&#160;</td>
          <td class="paramname"><em>tex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a texture if it has already been prepared, or removes it from the preparation queue. </p>

</div>
</div>
<a id="a13dca0881d38745fca4182d95f067d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13dca0881d38745fca4182d95f067d24">&#9670;&nbsp;</a></span>releaseTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">releaseTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1TextureContext.html">TextureContext</a>&#160;</td>
          <td class="paramname"><em>tc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a texture context, created by a previous call to prepare_texture(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release textures&ndash;this prevents conflicts from threading or multiple GSG's sharing textures (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_texture is called). </p>

</div>
</div>
<a id="a938e6bb53d88a6de38db9bd8564de7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938e6bb53d88a6de38db9bd8564de7e2">&#9670;&nbsp;</a></span>releaseVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">releaseVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1VertexBufferContext.html">VertexBufferContext</a>&#160;</td>
          <td class="paramname"><em>vbc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a data context, created by a previous call to prepare_vertex_buffer(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release datas&ndash;this prevents conflicts from threading or multiple GSG's sharing datas (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_vertex_buffer is called). </p>

</div>
</div>
<a id="ab32d5317df9a26b3fb353ad0086eb6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32d5317df9a26b3fb353ad0086eb6b1">&#9670;&nbsp;</a></span>setGraphicsMemoryLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setGraphicsMemoryLimit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an artificial cap on graphics memory that will be imposed on this GSG. </p>
<p>This limits the total amount of graphics memory, including texture memory and vertex buffer memory, that will be consumed by the GSG, regardless of whether the hardware claims to provide more graphics memory than this. It is useful to put a ceiling on graphics memory consumed, since some drivers seem to allow the application to consume more memory than the hardware can realistically support. </p>

</div>
</div>
<a id="a983b4d7358455ec69b18806d8564a8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983b4d7358455ec69b18806d8564a8d9">&#9670;&nbsp;</a></span>showGraphicsMemoryLru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">showGraphicsMemoryLru </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a>&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes to the indicated ostream a report of how the various textures and vertex buffers are allocated in the LRU. </p>

</div>
</div>
<a id="a9be3aa151abb068ab6404c5598adafc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be3aa151abb068ab6404c5598adafc1">&#9670;&nbsp;</a></span>showResidencyTrackers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">showResidencyTrackers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a>&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes to the indicated ostream a report of how the various textures and vertex buffers are allocated in the LRU. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 18 2017 01:46:59 for Panda3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
