<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Panda3D: GraphicsEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Panda3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepanda3d.html">panda3d</a></li><li class="navelem"><a class="el" href="namespacepanda3d_1_1core.html">core</a></li><li class="navelem"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html">GraphicsEngine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpanda3d_1_1core_1_1GraphicsEngine-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GraphicsEngine Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is the main interface to controlling the render process. There is typically only one <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> in an application, and it synchronizes rendering to all all of the active windows; although it is possible to have multiple <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> objects if multiple synchronicity groups are required.  
 <a href="classpanda3d_1_1core_1_1GraphicsEngine.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for GraphicsEngine:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpanda3d_1_1core_1_1GraphicsEngine.png" usemap="#GraphicsEngine_map" alt=""/>
  <map id="GraphicsEngine_map" name="GraphicsEngine_map">
<area href="classpanda3d_1_1core_1_1ReferenceCount.html" title="A base class for all things that want to be reference-counted. ReferenceCount works in conjunction wi..." alt="ReferenceCount" shape="rect" coords="0,56,104,80"/>
<area href="classpanda3d_1_1core_1_1MemoryBase.html" title="This class is intended to be the base class of all objects in Panda that might be allocated and delet..." alt="MemoryBase" shape="rect" coords="0,0,104,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a306f93ae67fcfe59bdeb6ee3956941b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a306f93ae67fcfe59bdeb6ee3956941b9">__init__</a> (Pipeline pipeline)</td></tr>
<tr class="memdesc:a306f93ae67fcfe59bdeb6ee3956941b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> object. The Pipeline is normally left to default to NULL, which indicates the global render pipeline, but it may be any Pipeline you choose.  <a href="#a306f93ae67fcfe59bdeb6ee3956941b9">More...</a><br /></td></tr>
<tr class="separator:a306f93ae67fcfe59bdeb6ee3956941b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eef16727bf20718768f2a70c5e7424"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#ae7eef16727bf20718768f2a70c5e7424">addWindow</a> (<a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a> window, int sort)</td></tr>
<tr class="memdesc:ae7eef16727bf20718768f2a70c5e7424"><td class="mdescLeft">&#160;</td><td class="mdescRight">This can be used to add a newly-created <a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html" title="This is a base class for the various different classes that represent the result of a frame of render...">GraphicsOutput</a> object (and its GSG) to the engine's list of windows, and requests that it be opened. This shouldn't be called by user code as make_output normally does this under the hood; it may be useful in esoteric cases in which a custom window object is used.  <a href="#ae7eef16727bf20718768f2a70c5e7424">More...</a><br /></td></tr>
<tr class="separator:ae7eef16727bf20718768f2a70c5e7424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020b18c109771c3dc51847dc6fd6ae7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a020b18c109771c3dc51847dc6fd6ae7a">dispatchCompute</a> (const <a class="el" href="classpanda3d_1_1core_1_1LVecBase3i.html">LVecBase3i</a> work_groups, const <a class="el" href="classpanda3d_1_1core_1_1ShaderAttrib.html">ShaderAttrib</a> sattr, <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html">GraphicsStateGuardian</a> gsg)</td></tr>
<tr class="memdesc:a020b18c109771c3dc51847dc6fd6ae7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks the indicated <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> to dispatch the compute shader in the given <a class="el" href="classpanda3d_1_1core_1_1ShaderAttrib.html">ShaderAttrib</a> using the given work group counts. This can act as an interface for running a one-off compute shader, without having to store it in the scene graph using a <a class="el" href="classpanda3d_1_1core_1_1ComputeNode.html" title="A special node, the sole purpose of which is to invoke a dispatch operation on the assigned compute s...">ComputeNode</a>.  <a href="#a020b18c109771c3dc51847dc6fd6ae7a">More...</a><br /></td></tr>
<tr class="separator:a020b18c109771c3dc51847dc6fd6ae7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ef02a99e2e487cce62131d55292c54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a52ef02a99e2e487cce62131d55292c54">extractTextureData</a> (<a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a> tex, <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html">GraphicsStateGuardian</a> gsg)</td></tr>
<tr class="memdesc:a52ef02a99e2e487cce62131d55292c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks the indicated <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> to retrieve the texture memory image of the indicated texture and store it in the texture's ram_image field. The image can then be written to disk via <a class="el" href="classpanda3d_1_1core_1_1Texture.html#adc5135cc6336cf82deaeac3afd01be60" title="Writes the texture to the named filename. ">Texture::write()</a>, or otherwise manipulated on the CPU.  <a href="#a52ef02a99e2e487cce62131d55292c54">More...</a><br /></td></tr>
<tr class="separator:a52ef02a99e2e487cce62131d55292c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436d1d5b4d6defe1a9b38ebf4d137cab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a436d1d5b4d6defe1a9b38ebf4d137cab">flipFrame</a> ()</td></tr>
<tr class="memdesc:a436d1d5b4d6defe1a9b38ebf4d137cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all the threads that started drawing their last frame to finish drawing, and then flips all the windows. It is not usually necessary to call this explicitly, unless you need to see the previous frame right away.  <a href="#a436d1d5b4d6defe1a9b38ebf4d137cab">More...</a><br /></td></tr>
<tr class="separator:a436d1d5b4d6defe1a9b38ebf4d137cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accba67b7ad0b2bc2ebf940e72b42e40b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#accba67b7ad0b2bc2ebf940e72b42e40b">getAutoFlip</a> ()</td></tr>
<tr class="memdesc:accba67b7ad0b2bc2ebf940e72b42e40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current setting for the auto-flip flag. See set_auto_flip.  <a href="#accba67b7ad0b2bc2ebf940e72b42e40b">More...</a><br /></td></tr>
<tr class="separator:accba67b7ad0b2bc2ebf940e72b42e40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00018cab9f699ebd7fd9bef09fba5da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1Loader.html">Loader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a00018cab9f699ebd7fd9bef09fba5da5">getDefaultLoader</a> ()</td></tr>
<tr class="memdesc:a00018cab9f699ebd7fd9bef09fba5da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classpanda3d_1_1core_1_1Loader.html" title="A convenient class for loading models from disk, in bam or egg format (or any of a number of other fo...">Loader</a> object that will be assigned to every GSG created with this <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a>. See GraphicsStateGuardian::set_loader().  <a href="#a00018cab9f699ebd7fd9bef09fba5da5">More...</a><br /></td></tr>
<tr class="separator:a00018cab9f699ebd7fd9bef09fba5da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af173f901e85ec467b0059212a926be4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#af173f901e85ec467b0059212a926be4a">getNumWindows</a> ()</td></tr>
<tr class="memdesc:af173f901e85ec467b0059212a926be4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of windows (or buffers) managed by the engine.  <a href="#af173f901e85ec467b0059212a926be4a">More...</a><br /></td></tr>
<tr class="separator:af173f901e85ec467b0059212a926be4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34015e786610c1bcc6e458352a7fcce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a34015e786610c1bcc6e458352a7fcce5">getPortalCull</a> ()</td></tr>
<tr class="memdesc:a34015e786610c1bcc6e458352a7fcce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current setting for the portal culling flag.  <a href="#a34015e786610c1bcc6e458352a7fcce5">More...</a><br /></td></tr>
<tr class="separator:a34015e786610c1bcc6e458352a7fcce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb05a5b28b99916442fafe4aa7cd049"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpanda3d_1_1core_1_1ReMutex.html">ReMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#afeb05a5b28b99916442fafe4aa7cd049">getRenderLock</a> ()</td></tr>
<tr class="memdesc:afeb05a5b28b99916442fafe4aa7cd049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classpanda3d_1_1core_1_1ReMutex.html">ReMutex</a> object that is held by the <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> during the entire call to render_frame(). While you hold this lock you can be confident that no part of the frame will be rendered (at least by the app thread).  <a href="#afeb05a5b28b99916442fafe4aa7cd049">More...</a><br /></td></tr>
<tr class="separator:afeb05a5b28b99916442fafe4aa7cd049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3968d963ffaef230a8cefdd8fb70a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1GraphicsThreadingModel.html">GraphicsThreadingModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#aba3968d963ffaef230a8cefdd8fb70a1">getThreadingModel</a> ()</td></tr>
<tr class="memdesc:aba3968d963ffaef230a8cefdd8fb70a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the threading model that will be applied to future objects. See set_threading_model().  <a href="#aba3968d963ffaef230a8cefdd8fb70a1">More...</a><br /></td></tr>
<tr class="separator:aba3968d963ffaef230a8cefdd8fb70a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77efc4c1207714f004f07fecc88a8572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a77efc4c1207714f004f07fecc88a8572">getWindow</a> (int n)</td></tr>
<tr class="memdesc:a77efc4c1207714f004f07fecc88a8572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth window or buffers managed by the engine, in sorted order.  <a href="#a77efc4c1207714f004f07fecc88a8572">More...</a><br /></td></tr>
<tr class="separator:a77efc4c1207714f004f07fecc88a8572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61acf33bf52f4e0b18ce6e7668cd74a1"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a61acf33bf52f4e0b18ce6e7668cd74a1">getWindows</a> ()</td></tr>
<tr class="separator:a61acf33bf52f4e0b18ce6e7668cd74a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af337ffd75e4f019ce15302c60715d84b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#af337ffd75e4f019ce15302c60715d84b">isEmpty</a> ()</td></tr>
<tr class="memdesc:af337ffd75e4f019ce15302c60715d84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no windows or buffers managed by the engine, false if there is at least one.  <a href="#af337ffd75e4f019ce15302c60715d84b">More...</a><br /></td></tr>
<tr class="separator:af337ffd75e4f019ce15302c60715d84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c45865e894860298277853f2d1f735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#ae3c45865e894860298277853f2d1f735">makeBuffer</a> (<a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a> host, str name, int sort, int x_size, int y_size)</td></tr>
<tr class="memdesc:ae3c45865e894860298277853f2d1f735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic shorthand for make_output. This is the preferred way to create an offscreen buffer, when you already have an onscreen window or another buffer to start with. For the first parameter, pass an existing <a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html" title="This is a base class for the various different classes that represent the result of a frame of render...">GraphicsOutput</a> object, e.g. the main window; this allows the buffer to adapt itself to that window's framebuffer properties, and allows maximum sharing of resources.  <a href="#ae3c45865e894860298277853f2d1f735">More...</a><br /></td></tr>
<tr class="separator:ae3c45865e894860298277853f2d1f735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f648b4bfa87f23d6041c8daeacc3abb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a4f648b4bfa87f23d6041c8daeacc3abb">makeBuffer</a> (<a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html">GraphicsStateGuardian</a> gsg, str name, int sort, int x_size, int y_size)</td></tr>
<tr class="memdesc:a4f648b4bfa87f23d6041c8daeacc3abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic shorthand for make_output. This flavor accepts a GSG rather than a <a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html" title="This is a base class for the various different classes that represent the result of a frame of render...">GraphicsOutput</a> as the first parameter, which is too limiting and disallows the possibility of creating a <a class="el" href="classpanda3d_1_1core_1_1ParasiteBuffer.html" title="This is a special GraphicsOutput type that acts a lot like a GraphicsBuffer, effectively allowing ren...">ParasiteBuffer</a> if the user's graphics hardware prefers that. It also attempts to request specific framebuffer properties and may therefore do a poorer job of sharing the GSG between the old buffer and the new.  <a href="#a4f648b4bfa87f23d6041c8daeacc3abb">More...</a><br /></td></tr>
<tr class="separator:a4f648b4bfa87f23d6041c8daeacc3abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e67ac5feb3f554c1bb1077ec02fd89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a26e67ac5feb3f554c1bb1077ec02fd89">makeOutput</a> (<a class="el" href="classpanda3d_1_1core_1_1GraphicsPipe.html">GraphicsPipe</a> pipe, str name, int sort, const <a class="el" href="classpanda3d_1_1core_1_1FrameBufferProperties.html">FrameBufferProperties</a> fb_prop, const <a class="el" href="classpanda3d_1_1core_1_1WindowProperties.html">WindowProperties</a> win_prop, int flags, <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html">GraphicsStateGuardian</a> gsg, <a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a> host)</td></tr>
<tr class="separator:a26e67ac5feb3f554c1bb1077ec02fd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a29aa57b6a55c44693ff8a6bcde9a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a68a29aa57b6a55c44693ff8a6bcde9a0">makeParasite</a> (<a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a> host, str name, int sort, int x_size, int y_size)</td></tr>
<tr class="memdesc:a68a29aa57b6a55c44693ff8a6bcde9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic shorthand for make_buffer.  <a href="#a68a29aa57b6a55c44693ff8a6bcde9a0">More...</a><br /></td></tr>
<tr class="separator:a68a29aa57b6a55c44693ff8a6bcde9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d50b998e1690e39445b9435006c3ae2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a8d50b998e1690e39445b9435006c3ae2">openWindows</a> ()</td></tr>
<tr class="memdesc:a8d50b998e1690e39445b9435006c3ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully opens (or closes) any windows that have recently been requested open or closed, without rendering any frames. It is not necessary to call this explicitly, since windows will be automatically opened or closed when the next frame is rendered, but you may call this if you want your windows now without seeing a frame go by.  <a href="#a8d50b998e1690e39445b9435006c3ae2">More...</a><br /></td></tr>
<tr class="separator:a8d50b998e1690e39445b9435006c3ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66bb1ae329c88ffcbf993363c24e35f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#aa66bb1ae329c88ffcbf993363c24e35f">readyFlip</a> ()</td></tr>
<tr class="memdesc:aa66bb1ae329c88ffcbf993363c24e35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all the threads that started drawing their last frame to finish drawing. Returns when all threads have actually finished drawing, as opposed to 'sync_frame' we seems to return once all draw calls have been submitted. Calling 'flip_frame' after this function should immediately cause a buffer flip. This function will only work in opengl right now, for all other graphics pipelines it will simply return immediately. In opengl it's a bit of a hack: it will attempt to read a single pixel from the frame buffer to force the graphics card to finish drawing before it returns.  <a href="#aa66bb1ae329c88ffcbf993363c24e35f">More...</a><br /></td></tr>
<tr class="separator:aa66bb1ae329c88ffcbf993363c24e35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a77a856d31c78e61d73e0999f2bbf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#ad8a77a856d31c78e61d73e0999f2bbf3">removeAllWindows</a> ()</td></tr>
<tr class="memdesc:ad8a77a856d31c78e61d73e0999f2bbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and closes all windows from the engine. This also cleans up and terminates any threads that have been started to service those windows.  <a href="#ad8a77a856d31c78e61d73e0999f2bbf3">More...</a><br /></td></tr>
<tr class="separator:ad8a77a856d31c78e61d73e0999f2bbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ca524b9d32e03a9c8fe97b241e8451"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#aa8ca524b9d32e03a9c8fe97b241e8451">removeWindow</a> (<a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a> window)</td></tr>
<tr class="memdesc:aa8ca524b9d32e03a9c8fe97b241e8451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the indicated window or offscreen buffer from the set of windows that will be processed when render_frame() is called. This also closes the window if it is open, and removes the window from its <a class="el" href="classpanda3d_1_1core_1_1GraphicsPipe.html" title="An object to create GraphicsOutputs that share a particular 3-D API. Normally, there will only be one...">GraphicsPipe</a>, allowing the window to be destructed if there are no other references to it. (However, the window may not be actually closed until next frame, if it is controlled by a sub-thread.)  <a href="#aa8ca524b9d32e03a9c8fe97b241e8451">More...</a><br /></td></tr>
<tr class="separator:aa8ca524b9d32e03a9c8fe97b241e8451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02dc4fd059e3df5caa7bde9913ff2e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#ad02dc4fd059e3df5caa7bde9913ff2e7">renderFrame</a> ()</td></tr>
<tr class="memdesc:ad02dc4fd059e3df5caa7bde9913ff2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the next frame in all the registered windows, and flips all of the frame buffers.  <a href="#ad02dc4fd059e3df5caa7bde9913ff2e7">More...</a><br /></td></tr>
<tr class="separator:ad02dc4fd059e3df5caa7bde9913ff2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5129d51478b2e92cafcf536ab15d7671"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a5129d51478b2e92cafcf536ab15d7671">resetAllWindows</a> (bool swapchain)</td></tr>
<tr class="memdesc:a5129d51478b2e92cafcf536ab15d7671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the framebuffer of the current window. This is currently used by DirectX 8 only. It calls a reset_window function on each active window to release/create old/new framebuffer.  <a href="#a5129d51478b2e92cafcf536ab15d7671">More...</a><br /></td></tr>
<tr class="separator:a5129d51478b2e92cafcf536ab15d7671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace57896a64ed945f07a73bee91d4b5b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#ace57896a64ed945f07a73bee91d4b5b1">setAutoFlip</a> (bool auto_flip)</td></tr>
<tr class="memdesc:ace57896a64ed945f07a73bee91d4b5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this flag true to indicate the <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> should automatically cause windows to sync and flip as soon as they have finished drawing, rather than waiting for all of the windows to finish drawing first so they can flip together.  <a href="#ace57896a64ed945f07a73bee91d4b5b1">More...</a><br /></td></tr>
<tr class="separator:ace57896a64ed945f07a73bee91d4b5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38211cfccd3f618bc56c62023d14d607"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a38211cfccd3f618bc56c62023d14d607">setDefaultLoader</a> (<a class="el" href="classpanda3d_1_1core_1_1Loader.html">Loader</a> loader)</td></tr>
<tr class="memdesc:a38211cfccd3f618bc56c62023d14d607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classpanda3d_1_1core_1_1Loader.html" title="A convenient class for loading models from disk, in bam or egg format (or any of a number of other fo...">Loader</a> object that will be assigned to every GSG created with this <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a>. See GraphicsStateGuardian::set_loader().  <a href="#a38211cfccd3f618bc56c62023d14d607">More...</a><br /></td></tr>
<tr class="separator:a38211cfccd3f618bc56c62023d14d607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6789d8714869810034cb517cdf7e47e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a6789d8714869810034cb517cdf7e47e9">setPortalCull</a> (bool value)</td></tr>
<tr class="memdesc:a6789d8714869810034cb517cdf7e47e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this flag true to indicate the <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> should start portal culling.  <a href="#a6789d8714869810034cb517cdf7e47e9">More...</a><br /></td></tr>
<tr class="separator:a6789d8714869810034cb517cdf7e47e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac869e6a317c435a000b8d729ac8fdfd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#ac869e6a317c435a000b8d729ac8fdfd2">setThreadingModel</a> (const <a class="el" href="classpanda3d_1_1core_1_1GraphicsThreadingModel.html">GraphicsThreadingModel</a> threading_model)</td></tr>
<tr class="memdesc:ac869e6a317c435a000b8d729ac8fdfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how future objects created via make_gsg(), make_buffer(), and make_window() will be threaded. This does not affect any already-created objects.  <a href="#ac869e6a317c435a000b8d729ac8fdfd2">More...</a><br /></td></tr>
<tr class="separator:ac869e6a317c435a000b8d729ac8fdfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d9dfb848e6ec16e1ea1e581116c532"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#ad7d9dfb848e6ec16e1ea1e581116c532">syncFrame</a> ()</td></tr>
<tr class="memdesc:ad7d9dfb848e6ec16e1ea1e581116c532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all the threads that started drawing their last frame to finish drawing. The windows are not yet flipped when this returns; see also flip_frame(). It is not usually necessary to call this explicitly, unless you need to see the previous frame right away.  <a href="#ad7d9dfb848e6ec16e1ea1e581116c532">More...</a><br /></td></tr>
<tr class="separator:ad7d9dfb848e6ec16e1ea1e581116c532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpanda3d_1_1core_1_1ReferenceCount')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a6c336617bdadf1660f079d3ceacf48bf">getRefCount</a> ()</td></tr>
<tr class="memdesc:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current reference count.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a6c336617bdadf1660f079d3ceacf48bf">More...</a><br /></td></tr>
<tr class="separator:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a895fd31ef3cb5add22a875fc9e5bee19">ref</a> ()</td></tr>
<tr class="memdesc:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly increments the reference count. User code should avoid using <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a895fd31ef3cb5add22a875fc9e5bee19" title="Explicitly increments the reference count. User code should avoid using ref() and unref() directly...">ref()</a> and <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02" title="Explicitly decrements the reference count. Note that the object will not be implicitly deleted by unr...">unref()</a> directly, which can result in missed reference counts. Instead, let a PointerTo object manage the reference counting automatically.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a895fd31ef3cb5add22a875fc9e5bee19">More...</a><br /></td></tr>
<tr class="separator:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a8d4e39df87bae0b1121681eb5e725812">testRefCountIntegrity</a> ()</td></tr>
<tr class="memdesc:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some easy checks to make sure that the reference count isn't completely bogus. Returns true if ok, false otherwise.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a8d4e39df87bae0b1121681eb5e725812">More...</a><br /></td></tr>
<tr class="separator:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a70436632764926b0453751c516623065">testRefCountNonzero</a> ()</td></tr>
<tr class="memdesc:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some easy checks to make sure that the reference count isn't zero, or completely bogus. Returns true if ok, false otherwise.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a70436632764926b0453751c516623065">More...</a><br /></td></tr>
<tr class="separator:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02">unref</a> ()</td></tr>
<tr class="memdesc:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly decrements the reference count. Note that the object will not be implicitly deleted by <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02" title="Explicitly decrements the reference count. Note that the object will not be implicitly deleted by unr...">unref()</a> simply because the reference count drops to zero. (Having a member function delete itself is problematic.) However, see the helper function unref_delete().  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02">More...</a><br /></td></tr>
<tr class="separator:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0c5e79757350b04676d07b7e280dbb17"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html">GraphicsEngine</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html#a0c5e79757350b04676d07b7e280dbb17">getGlobalPtr</a> ()</td></tr>
<tr class="separator:a0c5e79757350b04676d07b7e280dbb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a6ee74ed0904ab08032e044c5bea991dc">getClassType</a> ()</td></tr>
<tr class="separator:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is the main interface to controlling the render process. There is typically only one <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> in an application, and it synchronizes rendering to all all of the active windows; although it is possible to have multiple <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> objects if multiple synchronicity groups are required. </p>
<p>The <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> is responsible for managing the various cull and draw threads. The application simply calls engine-&gt;render_frame() and considers it done. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a306f93ae67fcfe59bdeb6ee3956941b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306f93ae67fcfe59bdeb6ee3956941b9">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__init__ </td>
          <td>(</td>
          <td class="paramtype">Pipeline&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> object. The Pipeline is normally left to default to NULL, which indicates the global render pipeline, but it may be any Pipeline you choose. </p>

</div>
</div>
<a id="ae7eef16727bf20718768f2a70c5e7424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7eef16727bf20718768f2a70c5e7424">&#9670;&nbsp;</a></span>addWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool addWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This can be used to add a newly-created <a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html" title="This is a base class for the various different classes that represent the result of a frame of render...">GraphicsOutput</a> object (and its GSG) to the engine's list of windows, and requests that it be opened. This shouldn't be called by user code as make_output normally does this under the hood; it may be useful in esoteric cases in which a custom window object is used. </p>

</div>
</div>
<a id="a020b18c109771c3dc51847dc6fd6ae7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020b18c109771c3dc51847dc6fd6ae7a">&#9670;&nbsp;</a></span>dispatchCompute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dispatchCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1LVecBase3i.html">LVecBase3i</a>&#160;</td>
          <td class="paramname"><em>work_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1ShaderAttrib.html">ShaderAttrib</a>&#160;</td>
          <td class="paramname"><em>sattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html">GraphicsStateGuardian</a>&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asks the indicated <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> to dispatch the compute shader in the given <a class="el" href="classpanda3d_1_1core_1_1ShaderAttrib.html">ShaderAttrib</a> using the given work group counts. This can act as an interface for running a one-off compute shader, without having to store it in the scene graph using a <a class="el" href="classpanda3d_1_1core_1_1ComputeNode.html" title="A special node, the sole purpose of which is to invoke a dispatch operation on the assigned compute s...">ComputeNode</a>. </p>
<p>Since this requires a round-trip to the draw thread, it may require waiting for the current thread to finish rendering if it is called in a multithreaded environment. However, you can call this several consecutive times on different textures for little additional cost.</p>
<p>The return value is true if the operation is successful, false otherwise. </p>

</div>
</div>
<a id="a52ef02a99e2e487cce62131d55292c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ef02a99e2e487cce62131d55292c54">&#9670;&nbsp;</a></span>extractTextureData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool extractTextureData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Texture.html">Texture</a>&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html">GraphicsStateGuardian</a>&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asks the indicated <a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html" title="Encapsulates all the communication with a particular instance of a given rendering backend...">GraphicsStateGuardian</a> to retrieve the texture memory image of the indicated texture and store it in the texture's ram_image field. The image can then be written to disk via <a class="el" href="classpanda3d_1_1core_1_1Texture.html#adc5135cc6336cf82deaeac3afd01be60" title="Writes the texture to the named filename. ">Texture::write()</a>, or otherwise manipulated on the CPU. </p>
<p>This is useful for retrieving the contents of a texture that has been somehow generated on the graphics card, instead of having been loaded the normal way via <a class="el" href="classpanda3d_1_1core_1_1Texture.html#a7bd2a835d951b17b5aa31df0f69125c6" title="Combine a 3-component image with a grayscale image to get a 4-component image. ">Texture::read()</a> or <a class="el" href="classpanda3d_1_1core_1_1Texture.html#a74ed60c04c3e6b2520ac8948b2ecfc65" title="Replaces the texture with the indicated image. ">Texture::load()</a>. It is particularly useful for getting the data associated with a compressed texture image.</p>
<p>Since this requires a round-trip to the draw thread, it may require waiting for the current thread to finish rendering if it is called in a multithreaded environment. However, you can call this several consecutive times on different textures for little additional cost.</p>
<p>If the texture has not yet been loaded to the GSG in question, it will be loaded immediately.</p>
<p>The return value is true if the operation is successful, false otherwise. </p>

</div>
</div>
<a id="a436d1d5b4d6defe1a9b38ebf4d137cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436d1d5b4d6defe1a9b38ebf4d137cab">&#9670;&nbsp;</a></span>flipFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">flipFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for all the threads that started drawing their last frame to finish drawing, and then flips all the windows. It is not usually necessary to call this explicitly, unless you need to see the previous frame right away. </p>

</div>
</div>
<a id="accba67b7ad0b2bc2ebf940e72b42e40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accba67b7ad0b2bc2ebf940e72b42e40b">&#9670;&nbsp;</a></span>getAutoFlip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getAutoFlip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current setting for the auto-flip flag. See set_auto_flip. </p>

</div>
</div>
<a id="a00018cab9f699ebd7fd9bef09fba5da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00018cab9f699ebd7fd9bef09fba5da5">&#9670;&nbsp;</a></span>getDefaultLoader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1Loader.html">Loader</a> getDefaultLoader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classpanda3d_1_1core_1_1Loader.html" title="A convenient class for loading models from disk, in bam or egg format (or any of a number of other fo...">Loader</a> object that will be assigned to every GSG created with this <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a>. See GraphicsStateGuardian::set_loader(). </p>

</div>
</div>
<a id="a0c5e79757350b04676d07b7e280dbb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5e79757350b04676d07b7e280dbb17">&#9670;&nbsp;</a></span>getGlobalPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html">GraphicsEngine</a> getGlobalPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af173f901e85ec467b0059212a926be4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af173f901e85ec467b0059212a926be4a">&#9670;&nbsp;</a></span>getNumWindows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumWindows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of windows (or buffers) managed by the engine. </p>

</div>
</div>
<a id="a34015e786610c1bcc6e458352a7fcce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34015e786610c1bcc6e458352a7fcce5">&#9670;&nbsp;</a></span>getPortalCull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getPortalCull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current setting for the portal culling flag. </p>

</div>
</div>
<a id="afeb05a5b28b99916442fafe4aa7cd049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb05a5b28b99916442fafe4aa7cd049">&#9670;&nbsp;</a></span>getRenderLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpanda3d_1_1core_1_1ReMutex.html">ReMutex</a> getRenderLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classpanda3d_1_1core_1_1ReMutex.html">ReMutex</a> object that is held by the <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> during the entire call to render_frame(). While you hold this lock you can be confident that no part of the frame will be rendered (at least by the app thread). </p>

</div>
</div>
<a id="aba3968d963ffaef230a8cefdd8fb70a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3968d963ffaef230a8cefdd8fb70a1">&#9670;&nbsp;</a></span>getThreadingModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1GraphicsThreadingModel.html">GraphicsThreadingModel</a> getThreadingModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the threading model that will be applied to future objects. See set_threading_model(). </p>

</div>
</div>
<a id="a77efc4c1207714f004f07fecc88a8572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77efc4c1207714f004f07fecc88a8572">&#9670;&nbsp;</a></span>getWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a> getWindow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nth window or buffers managed by the engine, in sorted order. </p>

</div>
</div>
<a id="a61acf33bf52f4e0b18ce6e7668cd74a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61acf33bf52f4e0b18ce6e7668cd74a1">&#9670;&nbsp;</a></span>getWindows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list getWindows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af337ffd75e4f019ce15302c60715d84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af337ffd75e4f019ce15302c60715d84b">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there are no windows or buffers managed by the engine, false if there is at least one. </p>

</div>
</div>
<a id="ae3c45865e894860298277853f2d1f735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c45865e894860298277853f2d1f735">&#9670;&nbsp;</a></span>makeBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a> makeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntactic shorthand for make_output. This is the preferred way to create an offscreen buffer, when you already have an onscreen window or another buffer to start with. For the first parameter, pass an existing <a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html" title="This is a base class for the various different classes that represent the result of a frame of render...">GraphicsOutput</a> object, e.g. the main window; this allows the buffer to adapt itself to that window's framebuffer properties, and allows maximum sharing of resources. </p>

</div>
</div>
<a id="a4f648b4bfa87f23d6041c8daeacc3abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f648b4bfa87f23d6041c8daeacc3abb">&#9670;&nbsp;</a></span>makeBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a> makeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html">GraphicsStateGuardian</a>&#160;</td>
          <td class="paramname"><em>gsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntactic shorthand for make_output. This flavor accepts a GSG rather than a <a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html" title="This is a base class for the various different classes that represent the result of a frame of render...">GraphicsOutput</a> as the first parameter, which is too limiting and disallows the possibility of creating a <a class="el" href="classpanda3d_1_1core_1_1ParasiteBuffer.html" title="This is a special GraphicsOutput type that acts a lot like a GraphicsBuffer, effectively allowing ren...">ParasiteBuffer</a> if the user's graphics hardware prefers that. It also attempts to request specific framebuffer properties and may therefore do a poorer job of sharing the GSG between the old buffer and the new. </p>
<p>For these reasons, this variant is a poor choice unless you are creating an offscreen buffer for the first time, without an onscreen window already in existence. If you already have an onscreen window, you should use the other flavor of make_buffer() instead, which accepts a <a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html" title="This is a base class for the various different classes that represent the result of a frame of render...">GraphicsOutput</a> as the first parameter. </p>

</div>
</div>
<a id="a26e67ac5feb3f554c1bb1077ec02fd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e67ac5feb3f554c1bb1077ec02fd89">&#9670;&nbsp;</a></span>makeOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a> makeOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsPipe.html">GraphicsPipe</a>&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1FrameBufferProperties.html">FrameBufferProperties</a>&#160;</td>
          <td class="paramname"><em>fb_prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1WindowProperties.html">WindowProperties</a>&#160;</td>
          <td class="paramname"><em>win_prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsStateGuardian.html">GraphicsStateGuardian</a>&#160;</td>
          <td class="paramname"><em>gsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a>&#160;</td>
          <td class="paramname"><em>host</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68a29aa57b6a55c44693ff8a6bcde9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a29aa57b6a55c44693ff8a6bcde9a0">&#9670;&nbsp;</a></span>makeParasite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a> makeParasite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntactic shorthand for make_buffer. </p>

</div>
</div>
<a id="a8d50b998e1690e39445b9435006c3ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d50b998e1690e39445b9435006c3ae2">&#9670;&nbsp;</a></span>openWindows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">openWindows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully opens (or closes) any windows that have recently been requested open or closed, without rendering any frames. It is not necessary to call this explicitly, since windows will be automatically opened or closed when the next frame is rendered, but you may call this if you want your windows now without seeing a frame go by. </p>

</div>
</div>
<a id="aa66bb1ae329c88ffcbf993363c24e35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66bb1ae329c88ffcbf993363c24e35f">&#9670;&nbsp;</a></span>readyFlip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readyFlip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for all the threads that started drawing their last frame to finish drawing. Returns when all threads have actually finished drawing, as opposed to 'sync_frame' we seems to return once all draw calls have been submitted. Calling 'flip_frame' after this function should immediately cause a buffer flip. This function will only work in opengl right now, for all other graphics pipelines it will simply return immediately. In opengl it's a bit of a hack: it will attempt to read a single pixel from the frame buffer to force the graphics card to finish drawing before it returns. </p>

</div>
</div>
<a id="ad8a77a856d31c78e61d73e0999f2bbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a77a856d31c78e61d73e0999f2bbf3">&#9670;&nbsp;</a></span>removeAllWindows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">removeAllWindows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and closes all windows from the engine. This also cleans up and terminates any threads that have been started to service those windows. </p>

</div>
</div>
<a id="aa8ca524b9d32e03a9c8fe97b241e8451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ca524b9d32e03a9c8fe97b241e8451">&#9670;&nbsp;</a></span>removeWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool removeWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1GraphicsOutput.html">GraphicsOutput</a>&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the indicated window or offscreen buffer from the set of windows that will be processed when render_frame() is called. This also closes the window if it is open, and removes the window from its <a class="el" href="classpanda3d_1_1core_1_1GraphicsPipe.html" title="An object to create GraphicsOutputs that share a particular 3-D API. Normally, there will only be one...">GraphicsPipe</a>, allowing the window to be destructed if there are no other references to it. (However, the window may not be actually closed until next frame, if it is controlled by a sub-thread.) </p>
<p>The return value is true if the window was removed, false if it was not found.</p>
<p>Unlike remove_all_windows(), this function does not terminate any of the threads that may have been started to service this window; they are left running (since you might open a new window later on these threads). If your intention is to clean up before shutting down, it is better to call remove_all_windows() then to call remove_window() one at a time. </p>

</div>
</div>
<a id="ad02dc4fd059e3df5caa7bde9913ff2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02dc4fd059e3df5caa7bde9913ff2e7">&#9670;&nbsp;</a></span>renderFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">renderFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders the next frame in all the registered windows, and flips all of the frame buffers. </p>

</div>
</div>
<a id="a5129d51478b2e92cafcf536ab15d7671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5129d51478b2e92cafcf536ab15d7671">&#9670;&nbsp;</a></span>resetAllWindows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">resetAllWindows </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>swapchain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the framebuffer of the current window. This is currently used by DirectX 8 only. It calls a reset_window function on each active window to release/create old/new framebuffer. </p>

</div>
</div>
<a id="ace57896a64ed945f07a73bee91d4b5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace57896a64ed945f07a73bee91d4b5b1">&#9670;&nbsp;</a></span>setAutoFlip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setAutoFlip </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_flip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this flag true to indicate the <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> should automatically cause windows to sync and flip as soon as they have finished drawing, rather than waiting for all of the windows to finish drawing first so they can flip together. </p>
<p>This only affects the timing of when the flip occurs. If this is true (the default), the flip occurs before render_frame() returns. If this is false, the flip occurs whenever flip_frame() is called, or at the beginning of the next call to render_frame(), if flip_frame() is never called. </p>

</div>
</div>
<a id="a38211cfccd3f618bc56c62023d14d607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38211cfccd3f618bc56c62023d14d607">&#9670;&nbsp;</a></span>setDefaultLoader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setDefaultLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Loader.html">Loader</a>&#160;</td>
          <td class="paramname"><em>loader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classpanda3d_1_1core_1_1Loader.html" title="A convenient class for loading models from disk, in bam or egg format (or any of a number of other fo...">Loader</a> object that will be assigned to every GSG created with this <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a>. See GraphicsStateGuardian::set_loader(). </p>

</div>
</div>
<a id="a6789d8714869810034cb517cdf7e47e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6789d8714869810034cb517cdf7e47e9">&#9670;&nbsp;</a></span>setPortalCull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setPortalCull </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this flag true to indicate the <a class="el" href="classpanda3d_1_1core_1_1GraphicsEngine.html" title="This class is the main interface to controlling the render process. There is typically only one Graph...">GraphicsEngine</a> should start portal culling. </p>

</div>
</div>
<a id="ac869e6a317c435a000b8d729ac8fdfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac869e6a317c435a000b8d729ac8fdfd2">&#9670;&nbsp;</a></span>setThreadingModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setThreadingModel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1GraphicsThreadingModel.html">GraphicsThreadingModel</a>&#160;</td>
          <td class="paramname"><em>threading_model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies how future objects created via make_gsg(), make_buffer(), and make_window() will be threaded. This does not affect any already-created objects. </p>

</div>
</div>
<a id="ad7d9dfb848e6ec16e1ea1e581116c532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d9dfb848e6ec16e1ea1e581116c532">&#9670;&nbsp;</a></span>syncFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">syncFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for all the threads that started drawing their last frame to finish drawing. The windows are not yet flipped when this returns; see also flip_frame(). It is not usually necessary to call this explicitly, unless you need to see the previous frame right away. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 18 2017 01:46:55 for Panda3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
