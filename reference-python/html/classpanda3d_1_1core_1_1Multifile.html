<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Panda3D: Multifile Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Panda3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepanda3d.html">panda3d</a></li><li class="navelem"><a class="el" href="namespacepanda3d_1_1core.html">core</a></li><li class="navelem"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html">Multifile</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpanda3d_1_1core_1_1Multifile-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Multifile Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A file that contains a set of files.  
 <a href="classpanda3d_1_1core_1_1Multifile.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Multifile:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpanda3d_1_1core_1_1Multifile.png" usemap="#Multifile_map" alt=""/>
  <map id="Multifile_map" name="Multifile_map">
<area href="classpanda3d_1_1core_1_1ReferenceCount.html" title="A base class for all things that want to be reference-counted. ReferenceCount works in conjunction wi..." alt="ReferenceCount" shape="rect" coords="0,56,104,80"/>
<area href="classpanda3d_1_1core_1_1MemoryBase.html" title="This class is intended to be the base class of all objects in Panda that might be allocated and delet..." alt="MemoryBase" shape="rect" coords="0,0,104,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a661c9fec719096053366368f803de8bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a661c9fec719096053366368f803de8bf">__init__</a> ()</td></tr>
<tr class="separator:a661c9fec719096053366368f803de8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e6721006aed030794e51d83167470d"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a07e6721006aed030794e51d83167470d">addSubfile</a> (str subfile_name, const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a> filename, int compression_level)</td></tr>
<tr class="memdesc:a07e6721006aed030794e51d83167470d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a file on disk as a subfile to the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. The file named by filename will be read and added to the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> at the next call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>. If there already exists a subfile with the indicated name, it is replaced without examining its contents (but see also update_subfile).  <a href="#a07e6721006aed030794e51d83167470d">More...</a><br /></td></tr>
<tr class="separator:a07e6721006aed030794e51d83167470d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3b21ce0f496db5dff24349fef47df9"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a1e3b21ce0f496db5dff24349fef47df9">addSubfile</a> (str subfile_name, <a class="el" href="classpanda3d_1_1core_1_1Istream.html">Istream</a> subfile_data, int compression_level)</td></tr>
<tr class="memdesc:a1e3b21ce0f496db5dff24349fef47df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a file from a stream as a subfile to the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. The indicated istream will be read and its contents added to the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> at the next call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>. The file will be added as a binary subfile.  <a href="#a1e3b21ce0f496db5dff24349fef47df9">More...</a><br /></td></tr>
<tr class="separator:a1e3b21ce0f496db5dff24349fef47df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69c8bf1f1dcf4e72552efff1fe3e87e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#aa69c8bf1f1dcf4e72552efff1fe3e87e">close</a> ()</td></tr>
<tr class="memdesc:aa69c8bf1f1dcf4e72552efff1fe3e87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> if it is open. All changes are flushed to disk, and the file becomes invalid for further operations until the next call to open().  <a href="#aa69c8bf1f1dcf4e72552efff1fe3e87e">More...</a><br /></td></tr>
<tr class="separator:aa69c8bf1f1dcf4e72552efff1fe3e87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8609eb0933ec3cc7e3b3e2a552294ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#ad8609eb0933ec3cc7e3b3e2a552294ee">compareSubfile</a> (int index, const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a> filename)</td></tr>
<tr class="memdesc:ad8609eb0933ec3cc7e3b3e2a552294ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a byte-for-byte comparison of the indicated file on disk with the nth subfile. Returns true if the files are equivalent, or false if they are different (or the file is missing).  <a href="#ad8609eb0933ec3cc7e3b3e2a552294ee">More...</a><br /></td></tr>
<tr class="separator:ad8609eb0933ec3cc7e3b3e2a552294ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046aee320b6f9220274390560990e91b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a046aee320b6f9220274390560990e91b">extractSubfile</a> (int index, const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a> filename)</td></tr>
<tr class="memdesc:a046aee320b6f9220274390560990e91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the nth subfile into a file with the given name.  <a href="#a046aee320b6f9220274390560990e91b">More...</a><br /></td></tr>
<tr class="separator:a046aee320b6f9220274390560990e91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31a4d17324a9def0b0edd4b84f831b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#af31a4d17324a9def0b0edd4b84f831b2">extractSubfileTo</a> (int index, <a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a> out)</td></tr>
<tr class="memdesc:af31a4d17324a9def0b0edd4b84f831b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the nth subfile to the indicated ostream.  <a href="#af31a4d17324a9def0b0edd4b84f831b2">More...</a><br /></td></tr>
<tr class="separator:af31a4d17324a9def0b0edd4b84f831b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac928dbf50c91c6b7ad669a3d901a287f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#ac928dbf50c91c6b7ad669a3d901a287f">findSubfile</a> (str subfile_name)</td></tr>
<tr class="memdesc:ac928dbf50c91c6b7ad669a3d901a287f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the subfile with the indicated name, or -1 if the named subfile is not within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>.  <a href="#ac928dbf50c91c6b7ad669a3d901a287f">More...</a><br /></td></tr>
<tr class="separator:ac928dbf50c91c6b7ad669a3d901a287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829df08537ae314dc10a47681fbbfde3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3">flush</a> ()</td></tr>
<tr class="memdesc:a829df08537ae314dc10a47681fbbfde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all contents of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> to disk. Until <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a> is called, add_subfile() and remove_subfile() do not actually do anything to disk. At this point, all of the recently-added subfiles are read and their contents are added to the end of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>, and the recently-removed subfiles are marked gone from the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>.  <a href="#a829df08537ae314dc10a47681fbbfde3">More...</a><br /></td></tr>
<tr class="separator:a829df08537ae314dc10a47681fbbfde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1a9d3f36b2a86daac4849b6d8b8b7b"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#ada1a9d3f36b2a86daac4849b6d8b8b7b">getEncryptionAlgorithm</a> ()</td></tr>
<tr class="memdesc:ada1a9d3f36b2a86daac4849b6d8b8b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the encryption algorithm that was specified by set_encryption_algorithm().  <a href="#ada1a9d3f36b2a86daac4849b6d8b8b7b">More...</a><br /></td></tr>
<tr class="separator:ada1a9d3f36b2a86daac4849b6d8b8b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a77fb816998ec3fe8b32fbe70b692b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a1a77fb816998ec3fe8b32fbe70b692b7">getEncryptionFlag</a> ()</td></tr>
<tr class="memdesc:a1a77fb816998ec3fe8b32fbe70b692b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the flag indicating whether subsequently-added subfiles should be encrypted before writing them to the multifile. See set_encryption_flag().  <a href="#a1a77fb816998ec3fe8b32fbe70b692b7">More...</a><br /></td></tr>
<tr class="separator:a1a77fb816998ec3fe8b32fbe70b692b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2282692d36dd91391634c53cfc01a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#abd2282692d36dd91391634c53cfc01a2">getEncryptionIterationCount</a> ()</td></tr>
<tr class="memdesc:abd2282692d36dd91391634c53cfc01a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value that was specified by set_encryption_iteration_count().  <a href="#abd2282692d36dd91391634c53cfc01a2">More...</a><br /></td></tr>
<tr class="separator:abd2282692d36dd91391634c53cfc01a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9687ec1df6c32838af641671129271"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a2f9687ec1df6c32838af641671129271">getEncryptionKeyLength</a> ()</td></tr>
<tr class="memdesc:a2f9687ec1df6c32838af641671129271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the encryption key length, in bits, that was specified by set_encryption_key_length().  <a href="#a2f9687ec1df6c32838af641671129271">More...</a><br /></td></tr>
<tr class="separator:a2f9687ec1df6c32838af641671129271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0d1e6fabfa2a68b820fb14c0592d06"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a5a0d1e6fabfa2a68b820fb14c0592d06">getEncryptionPassword</a> ()</td></tr>
<tr class="memdesc:a5a0d1e6fabfa2a68b820fb14c0592d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the password that will be used to encrypt subfiles subsequently added to the multifile. See set_encryption_password().  <a href="#a5a0d1e6fabfa2a68b820fb14c0592d06">More...</a><br /></td></tr>
<tr class="separator:a5a0d1e6fabfa2a68b820fb14c0592d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a56ef211c6852cd3aaeb17e558c4885"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a9a56ef211c6852cd3aaeb17e558c4885">getHeaderPrefix</a> ()</td></tr>
<tr class="memdesc:a9a56ef211c6852cd3aaeb17e558c4885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string that preceded the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> header on the file, if any. See set_header_prefix().  <a href="#a9a56ef211c6852cd3aaeb17e558c4885">More...</a><br /></td></tr>
<tr class="separator:a9a56ef211c6852cd3aaeb17e558c4885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce2a3f5c6a12aad4845802f036cdc75"><td class="memItemLeft" align="right" valign="top">Streampos&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a0ce2a3f5c6a12aad4845802f036cdc75">getIndexEnd</a> ()</td></tr>
<tr class="memdesc:a0ce2a3f5c6a12aad4845802f036cdc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first byte that is guaranteed to follow any index byte already written to disk in the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>.  <a href="#a0ce2a3f5c6a12aad4845802f036cdc75">More...</a><br /></td></tr>
<tr class="separator:a0ce2a3f5c6a12aad4845802f036cdc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1181557963644bf130bf3f64010bce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#aab1181557963644bf130bf3f64010bce">getMultifileName</a> ()</td></tr>
<tr class="memdesc:aab1181557963644bf130bf3f64010bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the filename of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>, if it is available.  <a href="#aab1181557963644bf130bf3f64010bce">More...</a><br /></td></tr>
<tr class="separator:aab1181557963644bf130bf3f64010bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8737e1495f73b9ef938a0324df16f02b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a8737e1495f73b9ef938a0324df16f02b">getNumSubfiles</a> ()</td></tr>
<tr class="memdesc:a8737e1495f73b9ef938a0324df16f02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of subfiles within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. The subfiles may be accessed in alphabetical order by iterating through [0 .. get_num_subfiles()).  <a href="#a8737e1495f73b9ef938a0324df16f02b">More...</a><br /></td></tr>
<tr class="separator:a8737e1495f73b9ef938a0324df16f02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62afb67c0a8a5350a60d4d0f60acfcdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a62afb67c0a8a5350a60d4d0f60acfcdb">getRecordTimestamp</a> ()</td></tr>
<tr class="memdesc:a62afb67c0a8a5350a60d4d0f60acfcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the flag indicating whether timestamps should be recorded within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> or not. See set_record_timestamp().  <a href="#a62afb67c0a8a5350a60d4d0f60acfcdb">More...</a><br /></td></tr>
<tr class="separator:a62afb67c0a8a5350a60d4d0f60acfcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240c1c043ab787abe65f4617ff52d014"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a240c1c043ab787abe65f4617ff52d014">getScaleFactor</a> ()</td></tr>
<tr class="memdesc:a240c1c043ab787abe65f4617ff52d014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal scale factor for this <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. See set_scale_factor().  <a href="#a240c1c043ab787abe65f4617ff52d014">More...</a><br /></td></tr>
<tr class="separator:a240c1c043ab787abe65f4617ff52d014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d5a31ec30354b4fa53dbe0bf19d92c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a39d5a31ec30354b4fa53dbe0bf19d92c">getSubfileInternalLength</a> (int index)</td></tr>
<tr class="memdesc:a39d5a31ec30354b4fa53dbe0bf19d92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes the indicated subfile consumes within the archive. For compressed subfiles, this will generally be smaller than get_subfile_length(); for encrypted (but noncompressed) subfiles, it may be slightly different, for noncompressed and nonencrypted subfiles, it will be equal.  <a href="#a39d5a31ec30354b4fa53dbe0bf19d92c">More...</a><br /></td></tr>
<tr class="separator:a39d5a31ec30354b4fa53dbe0bf19d92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e920f136d9845f5693478c9997a5529"><td class="memItemLeft" align="right" valign="top">Streampos&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a2e920f136d9845f5693478c9997a5529">getSubfileInternalStart</a> (int index)</td></tr>
<tr class="memdesc:a2e920f136d9845f5693478c9997a5529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the starting byte position within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> at which the indicated subfile begins. This may be used, with get_subfile_internal_length(), for low-level access to the subfile, but usually it is better to use open_read_subfile() instead (which automatically decrypts and/or uncompresses the subfile data).  <a href="#a2e920f136d9845f5693478c9997a5529">More...</a><br /></td></tr>
<tr class="separator:a2e920f136d9845f5693478c9997a5529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f89195b1f30c6b63d3c6776b03275dd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a3f89195b1f30c6b63d3c6776b03275dd">getSubfileLength</a> (int index)</td></tr>
<tr class="memdesc:a3f89195b1f30c6b63d3c6776b03275dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uncompressed data length of the nth subfile. This might return 0 if the subfile has recently been added and <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a> has not yet been called.  <a href="#a3f89195b1f30c6b63d3c6776b03275dd">More...</a><br /></td></tr>
<tr class="separator:a3f89195b1f30c6b63d3c6776b03275dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102dd8f674097acf8c2c4d2acf9aa732"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a102dd8f674097acf8c2c4d2acf9aa732">getSubfileName</a> (int index)</td></tr>
<tr class="memdesc:a102dd8f674097acf8c2c4d2acf9aa732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the nth subfile.  <a href="#a102dd8f674097acf8c2c4d2acf9aa732">More...</a><br /></td></tr>
<tr class="separator:a102dd8f674097acf8c2c4d2acf9aa732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1242891318dd73ed8b507a9111f69a10"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a1242891318dd73ed8b507a9111f69a10">getSubfileNames</a> ()</td></tr>
<tr class="separator:a1242891318dd73ed8b507a9111f69a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be6f15bbe06540d8fa278eccae1666c"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a9be6f15bbe06540d8fa278eccae1666c">getSubfileTimestamp</a> (int index)</td></tr>
<tr class="memdesc:a9be6f15bbe06540d8fa278eccae1666c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the modification time of the nth subfile. If this is called on an older .mf file, which did not store individual timestamps in the file (or if get_record_timestamp() is false), this will return the modification time of the overall multifile.  <a href="#a9be6f15bbe06540d8fa278eccae1666c">More...</a><br /></td></tr>
<tr class="separator:a9be6f15bbe06540d8fa278eccae1666c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18097ef35cac00ba6eea85b262b7871f"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a18097ef35cac00ba6eea85b262b7871f">getTimestamp</a> ()</td></tr>
<tr class="memdesc:a18097ef35cac00ba6eea85b262b7871f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the modification timestamp of the overall <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. This indicates the most recent date at which subfiles were added or removed from the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. Note that it is logically possible for an individual subfile to have a more recent timestamp than the overall timestamp.  <a href="#a18097ef35cac00ba6eea85b262b7871f">More...</a><br /></td></tr>
<tr class="separator:a18097ef35cac00ba6eea85b262b7871f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb753c8fd60865597eeafa6db549588"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#aeeb753c8fd60865597eeafa6db549588">hasDirectory</a> (str subfile_name)</td></tr>
<tr class="memdesc:aeeb753c8fd60865597eeafa6db549588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the indicated subfile name is the directory prefix to one or more files within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. That is, the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> contains at least one file named "subfile_name/...".  <a href="#aeeb753c8fd60865597eeafa6db549588">More...</a><br /></td></tr>
<tr class="separator:aeeb753c8fd60865597eeafa6db549588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184aefb677f70bb13cec310957abdb03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a184aefb677f70bb13cec310957abdb03">isReadValid</a> ()</td></tr>
<tr class="memdesc:a184aefb677f70bb13cec310957abdb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> has been opened for read mode and there have been no errors, and individual Subfile contents may be extracted.  <a href="#a184aefb677f70bb13cec310957abdb03">More...</a><br /></td></tr>
<tr class="separator:a184aefb677f70bb13cec310957abdb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5e475c5655406d993a32f667b63445"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#acd5e475c5655406d993a32f667b63445">isSubfileCompressed</a> (int index)</td></tr>
<tr class="memdesc:acd5e475c5655406d993a32f667b63445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the indicated subfile has been compressed when stored within the archive, false otherwise.  <a href="#acd5e475c5655406d993a32f667b63445">More...</a><br /></td></tr>
<tr class="separator:acd5e475c5655406d993a32f667b63445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b5b92e4fb94ee0c24c2854b38fb681"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a88b5b92e4fb94ee0c24c2854b38fb681">isSubfileEncrypted</a> (int index)</td></tr>
<tr class="memdesc:a88b5b92e4fb94ee0c24c2854b38fb681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the indicated subfile has been encrypted when stored within the archive, false otherwise.  <a href="#a88b5b92e4fb94ee0c24c2854b38fb681">More...</a><br /></td></tr>
<tr class="separator:a88b5b92e4fb94ee0c24c2854b38fb681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2394db5675b118d558b72d70c166b3f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a2394db5675b118d558b72d70c166b3f8">isSubfileText</a> (int index)</td></tr>
<tr class="memdesc:a2394db5675b118d558b72d70c166b3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the indicated subfile represents text data, or false if it represents binary data. If the file is text data, it may have been processed by end-of-line conversion when it was added. (But the actual bits in the multifile will represent the standard Unix end-of-line convention, e.g. <br />
 instead of <br />
.)  <a href="#a2394db5675b118d558b72d70c166b3f8">More...</a><br /></td></tr>
<tr class="separator:a2394db5675b118d558b72d70c166b3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4de0e02a3db53e1e9a938f3e9eef70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#afd4de0e02a3db53e1e9a938f3e9eef70">isWriteValid</a> ()</td></tr>
<tr class="memdesc:afd4de0e02a3db53e1e9a938f3e9eef70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> has been opened for write mode and there have been no errors, and Subfiles may be added or removed from the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>.  <a href="#afd4de0e02a3db53e1e9a938f3e9eef70">More...</a><br /></td></tr>
<tr class="separator:afd4de0e02a3db53e1e9a938f3e9eef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0601a5e4cc80fbfc626db580f9814c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#ac0601a5e4cc80fbfc626db580f9814c7">ls</a> (<a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a> out)</td></tr>
<tr class="memdesc:ac0601a5e4cc80fbfc626db580f9814c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows a list of all subfiles within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>.  <a href="#ac0601a5e4cc80fbfc626db580f9814c7">More...</a><br /></td></tr>
<tr class="separator:ac0601a5e4cc80fbfc626db580f9814c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b88858bf7f30aa7906b48716c3b6b71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a6b88858bf7f30aa7906b48716c3b6b71">needsRepack</a> ()</td></tr>
<tr class="memdesc:a6b88858bf7f30aa7906b48716c3b6b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> index is suboptimal and should be repacked. Call <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#af69b8f30c638a2feb8f02e4f3d173884" title="Forces a complete rewrite of the Multifile and all of its contents, so that its index will appear at ...">repack()</a> to achieve this.  <a href="#a6b88858bf7f30aa7906b48716c3b6b71">More...</a><br /></td></tr>
<tr class="separator:a6b88858bf7f30aa7906b48716c3b6b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f4de0106da336821310fba018b1ef3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#ad5f4de0106da336821310fba018b1ef3">openRead</a> (const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a> multifile_name, Streampos offset)</td></tr>
<tr class="memdesc:ad5f4de0106da336821310fba018b1ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the named <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> on disk for reading. The <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> index is read in, and the list of subfiles becomes available; individual subfiles may then be extracted or read, but the list of subfiles may not be modified.  <a href="#ad5f4de0106da336821310fba018b1ef3">More...</a><br /></td></tr>
<tr class="separator:ad5f4de0106da336821310fba018b1ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671ac11cf945293b3e7004784fde5c58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a671ac11cf945293b3e7004784fde5c58">openRead</a> (<a class="el" href="classpanda3d_1_1core_1_1IStreamWrapper.html">IStreamWrapper</a> multifile_stream, bool owns_pointer, Streampos offset)</td></tr>
<tr class="memdesc:a671ac11cf945293b3e7004784fde5c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an anonymous <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> for reading using an istream. There must be seek functionality via seekg() and tellg() on the istream.  <a href="#a671ac11cf945293b3e7004784fde5c58">More...</a><br /></td></tr>
<tr class="separator:a671ac11cf945293b3e7004784fde5c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c1ffeae6d0b2babf1ba7d3017fb9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1Istream.html">Istream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#ab1c1ffeae6d0b2babf1ba7d3017fb9ec">openReadSubfile</a> (int index)</td></tr>
<tr class="memdesc:ab1c1ffeae6d0b2babf1ba7d3017fb9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an istream that may be used to read the indicated subfile. You may seek() within this istream to your heart's content; even though it will be a reference to the already-opened pfstream of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> itself, byte 0 appears to be the beginning of the subfile and EOF appears to be the end of the subfile.  <a href="#ab1c1ffeae6d0b2babf1ba7d3017fb9ec">More...</a><br /></td></tr>
<tr class="separator:ab1c1ffeae6d0b2babf1ba7d3017fb9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3ef281de52a50930d83c71ac47eb07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a4b3ef281de52a50930d83c71ac47eb07">openReadWrite</a> (const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a> multifile_name)</td></tr>
<tr class="memdesc:a4b3ef281de52a50930d83c71ac47eb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the named <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> on disk for reading and writing. If there already exists a file by that name, its index is read. Subfiles may be added or removed, and the resulting changes will be written to the named file.  <a href="#a4b3ef281de52a50930d83c71ac47eb07">More...</a><br /></td></tr>
<tr class="separator:a4b3ef281de52a50930d83c71ac47eb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cdf93795d916c68181f5149b074809"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a99cdf93795d916c68181f5149b074809">openReadWrite</a> (<a class="el" href="classpanda3d_1_1core_1_1Iostream.html">Iostream</a> multifile_stream, bool owns_pointer)</td></tr>
<tr class="memdesc:a99cdf93795d916c68181f5149b074809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an anonymous <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> for reading and writing using an iostream. There must be seek functionality via seekg()/seekp() and tellg()/tellp() on the iostream.  <a href="#a99cdf93795d916c68181f5149b074809">More...</a><br /></td></tr>
<tr class="separator:a99cdf93795d916c68181f5149b074809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1dcd194644998f1d0554c05e5ea0d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a3f1dcd194644998f1d0554c05e5ea0d0">openWrite</a> (const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a> multifile_name)</td></tr>
<tr class="memdesc:a3f1dcd194644998f1d0554c05e5ea0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the named <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> on disk for writing. If there already exists a file by that name, it is truncated. The <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> is then prepared for accepting a brand new set of subfiles, which will be written to the indicated filename. Individual subfiles may not be extracted or read.  <a href="#a3f1dcd194644998f1d0554c05e5ea0d0">More...</a><br /></td></tr>
<tr class="separator:a3f1dcd194644998f1d0554c05e5ea0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683068c03489224503e01f3326eb55b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a683068c03489224503e01f3326eb55b4">openWrite</a> (<a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a> multifile_stream, bool owns_pointer)</td></tr>
<tr class="memdesc:a683068c03489224503e01f3326eb55b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an anonymous <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> for writing using an ostream. There must be seek functionality via seekp() and tellp() on the pstream.  <a href="#a683068c03489224503e01f3326eb55b4">More...</a><br /></td></tr>
<tr class="separator:a683068c03489224503e01f3326eb55b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe34a3beba58bdae238301d02aac87f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#abe34a3beba58bdae238301d02aac87f0">output</a> (<a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a> out)</td></tr>
<tr class="separator:abe34a3beba58bdae238301d02aac87f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39650a303a16e0fd33122e6d53dbc942"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a39650a303a16e0fd33122e6d53dbc942">readSubfile</a> (int index)</td></tr>
<tr class="memdesc:a39650a303a16e0fd33122e6d53dbc942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that contains the entire contents of the indicated subfile.  <a href="#a39650a303a16e0fd33122e6d53dbc942">More...</a><br /></td></tr>
<tr class="separator:a39650a303a16e0fd33122e6d53dbc942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd58c550dc8eed03aeb7e6d1873f118"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a3cd58c550dc8eed03aeb7e6d1873f118">removeSubfile</a> (int index)</td></tr>
<tr class="memdesc:a3cd58c550dc8eed03aeb7e6d1873f118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth subfile from the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. This will cause all subsequent index numbers to decrease by one. The file will not actually be removed from the disk until the next call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>.  <a href="#a3cd58c550dc8eed03aeb7e6d1873f118">More...</a><br /></td></tr>
<tr class="separator:a3cd58c550dc8eed03aeb7e6d1873f118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4b82933b6d6d30d078291c151b8b19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a0b4b82933b6d6d30d078291c151b8b19">removeSubfile</a> (str subfile_name)</td></tr>
<tr class="memdesc:a0b4b82933b6d6d30d078291c151b8b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the named subfile from the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>, if it exists; returns true if successfully removed, or false if it did not exist in the first place. The file will not actually be removed from the disk until the next call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>.  <a href="#a0b4b82933b6d6d30d078291c151b8b19">More...</a><br /></td></tr>
<tr class="separator:a0b4b82933b6d6d30d078291c151b8b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69b8f30c638a2feb8f02e4f3d173884"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#af69b8f30c638a2feb8f02e4f3d173884">repack</a> ()</td></tr>
<tr class="memdesc:af69b8f30c638a2feb8f02e4f3d173884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces a complete rewrite of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> and all of its contents, so that its index will appear at the beginning of the file with all of the subfiles listed in alphabetical order. This is considered optimal for reading, and is the standard configuration; but it is not essential to do this.  <a href="#af69b8f30c638a2feb8f02e4f3d173884">More...</a><br /></td></tr>
<tr class="separator:af69b8f30c638a2feb8f02e4f3d173884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbe1e2abc9939930434f7961e07c614"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#acbbe1e2abc9939930434f7961e07c614">scanDirectory</a> (VectorString contents, str subfile_name)</td></tr>
<tr class="memdesc:acbbe1e2abc9939930434f7961e07c614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Considers subfile_name to be the name of a subdirectory within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>, but not a file itself; fills the given vector up with the sorted list of subdirectories or files within the named directory.  <a href="#acbbe1e2abc9939930434f7961e07c614">More...</a><br /></td></tr>
<tr class="separator:acbbe1e2abc9939930434f7961e07c614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3622dbfa30e843756040ec6129022680"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a3622dbfa30e843756040ec6129022680">setEncryptionAlgorithm</a> (str encryption_algorithm)</td></tr>
<tr class="memdesc:a3622dbfa30e843756040ec6129022680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the encryption algorithm that should be used for future calls to add_subfile(). The default is whatever is specified by the encryption-algorithm config variable. The complete set of available algorithms is defined by the current version of OpenSSL.  <a href="#a3622dbfa30e843756040ec6129022680">More...</a><br /></td></tr>
<tr class="separator:a3622dbfa30e843756040ec6129022680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76fb9378517ed64b59e1285c1db2757"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#ac76fb9378517ed64b59e1285c1db2757">setEncryptionFlag</a> (bool flag)</td></tr>
<tr class="memdesc:ac76fb9378517ed64b59e1285c1db2757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the flag indicating whether subsequently-added subfiles should be encrypted before writing them to the multifile. If true, subfiles will be encrypted; if false (the default), they will be written without encryption.  <a href="#ac76fb9378517ed64b59e1285c1db2757">More...</a><br /></td></tr>
<tr class="separator:ac76fb9378517ed64b59e1285c1db2757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49764fa6f31f3006de7ae158f687856d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a49764fa6f31f3006de7ae158f687856d">setEncryptionIterationCount</a> (int encryption_iteration_count)</td></tr>
<tr class="memdesc:a49764fa6f31f3006de7ae158f687856d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the number of times to repeatedly hash the key before writing it to the stream in future calls to add_subfile(). Its purpose is to make it computationally more expensive for an attacker to search the key space exhaustively. This should be a multiple of 1,000 and should not exceed about 65 million; the value 0 indicates just one application of the hashing algorithm.  <a href="#a49764fa6f31f3006de7ae158f687856d">More...</a><br /></td></tr>
<tr class="separator:a49764fa6f31f3006de7ae158f687856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758ecbcbbca7479611d2e2e4803b4f01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a758ecbcbbca7479611d2e2e4803b4f01">setEncryptionKeyLength</a> (int encryption_key_length)</td></tr>
<tr class="memdesc:a758ecbcbbca7479611d2e2e4803b4f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the length of the key, in bits, that should be used to encrypt the stream in future calls to add_subfile(). The default is whatever is specified by the encryption-key-length config variable.  <a href="#a758ecbcbbca7479611d2e2e4803b4f01">More...</a><br /></td></tr>
<tr class="separator:a758ecbcbbca7479611d2e2e4803b4f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52975417e489873ef67b9d604b7709c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#ab52975417e489873ef67b9d604b7709c">setEncryptionPassword</a> (str encryption_password)</td></tr>
<tr class="memdesc:ab52975417e489873ef67b9d604b7709c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the password that will be used to encrypt subfiles subsequently added to the multifile, if the encryption flag is also set true (see set_encryption_flag()).  <a href="#ab52975417e489873ef67b9d604b7709c">More...</a><br /></td></tr>
<tr class="separator:ab52975417e489873ef67b9d604b7709c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5787f4065b9afe542943ec115a336c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#aac5787f4065b9afe542943ec115a336c">setHeaderPrefix</a> (str header_prefix)</td></tr>
<tr class="memdesc:aac5787f4065b9afe542943ec115a336c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the string which is written to the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> before the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> header. This string must begin with a hash mark and end with a newline character; and if it includes embedded newline characters, each one must be followed by a hash mark. If these conditions are not initially true, the string will be modified as necessary to make it so.  <a href="#aac5787f4065b9afe542943ec115a336c">More...</a><br /></td></tr>
<tr class="separator:aac5787f4065b9afe542943ec115a336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69da1a34a214dc6e07f7d3659a1497e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#ad69da1a34a214dc6e07f7d3659a1497e">setMultifileName</a> (const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a> multifile_name)</td></tr>
<tr class="memdesc:ad69da1a34a214dc6e07f7d3659a1497e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the filename of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. This is primarily used for documentation purposes only; changing this name does not open the indicated file. See open_read() or open_write() for that.  <a href="#ad69da1a34a214dc6e07f7d3659a1497e">More...</a><br /></td></tr>
<tr class="separator:ad69da1a34a214dc6e07f7d3659a1497e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02889eade453b4f1513cc719aa2c0509"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a02889eade453b4f1513cc719aa2c0509">setRecordTimestamp</a> (bool record_timestamp)</td></tr>
<tr class="memdesc:a02889eade453b4f1513cc719aa2c0509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the flag indicating whether timestamps should be recorded within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> or not. The default is true, indicating the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> will record timestamps for the overall file and also for each subfile.  <a href="#a02889eade453b4f1513cc719aa2c0509">More...</a><br /></td></tr>
<tr class="separator:a02889eade453b4f1513cc719aa2c0509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87ff2f95d211c79584b22638bf4fe1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#ac87ff2f95d211c79584b22638bf4fe1e">setScaleFactor</a> (size_t scale_factor)</td></tr>
<tr class="memdesc:ac87ff2f95d211c79584b22638bf4fe1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the internal scale factor for this <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>.  <a href="#ac87ff2f95d211c79584b22638bf4fe1e">More...</a><br /></td></tr>
<tr class="separator:ac87ff2f95d211c79584b22638bf4fe1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60173b28cb1502cce2816ef2493d8c4d"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a60173b28cb1502cce2816ef2493d8c4d">updateSubfile</a> (str subfile_name, const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a> filename, int compression_level)</td></tr>
<tr class="memdesc:a60173b28cb1502cce2816ef2493d8c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a file on disk to the subfile. If a subfile already exists with the same name, its contents are compared byte-for-byte to the disk file, and it is replaced only if it is different; otherwise, the multifile is left unchanged.  <a href="#a60173b28cb1502cce2816ef2493d8c4d">More...</a><br /></td></tr>
<tr class="separator:a60173b28cb1502cce2816ef2493d8c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpanda3d_1_1core_1_1ReferenceCount')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a6c336617bdadf1660f079d3ceacf48bf">getRefCount</a> ()</td></tr>
<tr class="memdesc:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current reference count.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a6c336617bdadf1660f079d3ceacf48bf">More...</a><br /></td></tr>
<tr class="separator:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a895fd31ef3cb5add22a875fc9e5bee19">ref</a> ()</td></tr>
<tr class="memdesc:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly increments the reference count. User code should avoid using <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a895fd31ef3cb5add22a875fc9e5bee19" title="Explicitly increments the reference count. User code should avoid using ref() and unref() directly...">ref()</a> and <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02" title="Explicitly decrements the reference count. Note that the object will not be implicitly deleted by unr...">unref()</a> directly, which can result in missed reference counts. Instead, let a PointerTo object manage the reference counting automatically.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a895fd31ef3cb5add22a875fc9e5bee19">More...</a><br /></td></tr>
<tr class="separator:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a8d4e39df87bae0b1121681eb5e725812">testRefCountIntegrity</a> ()</td></tr>
<tr class="memdesc:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some easy checks to make sure that the reference count isn't completely bogus. Returns true if ok, false otherwise.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a8d4e39df87bae0b1121681eb5e725812">More...</a><br /></td></tr>
<tr class="separator:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a70436632764926b0453751c516623065">testRefCountNonzero</a> ()</td></tr>
<tr class="memdesc:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some easy checks to make sure that the reference count isn't zero, or completely bogus. Returns true if ok, false otherwise.  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#a70436632764926b0453751c516623065">More...</a><br /></td></tr>
<tr class="separator:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02">unref</a> ()</td></tr>
<tr class="memdesc:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly decrements the reference count. Note that the object will not be implicitly deleted by <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02" title="Explicitly decrements the reference count. Note that the object will not be implicitly deleted by unr...">unref()</a> simply because the reference count drops to zero. (Having a member function delete itself is problematic.) However, see the helper function unref_delete().  <a href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02">More...</a><br /></td></tr>
<tr class="separator:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abc10612dc39c975154ed5d39e308fcab"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#abc10612dc39c975154ed5d39e308fcab">closeReadSubfile</a> (<a class="el" href="classpanda3d_1_1core_1_1Istream.html">Istream</a> stream)</td></tr>
<tr class="memdesc:abc10612dc39c975154ed5d39e308fcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a file opened by a previous call to open_read_subfile(). This really just deletes the istream pointer, but it is recommended to use this interface instead of deleting it explicitly, to help work around compiler issues.  <a href="#abc10612dc39c975154ed5d39e308fcab">More...</a><br /></td></tr>
<tr class="separator:abc10612dc39c975154ed5d39e308fcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f75f2c14efc57231ffa1425f4eb7380"><td class="memItemLeft" align="right" valign="top">static str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a2f75f2c14efc57231ffa1425f4eb7380">getMagicNumber</a> ()</td></tr>
<tr class="memdesc:a2f75f2c14efc57231ffa1425f4eb7380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with the first n bytes written to a <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>, to identify it as a <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>.  <a href="#a2f75f2c14efc57231ffa1425f4eb7380">More...</a><br /></td></tr>
<tr class="separator:a2f75f2c14efc57231ffa1425f4eb7380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a6ee74ed0904ab08032e044c5bea991dc">getClassType</a> ()</td></tr>
<tr class="separator:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A file that contains a set of files. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a661c9fec719096053366368f803de8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661c9fec719096053366368f803de8bf">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__init__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07e6721006aed030794e51d83167470d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e6721006aed030794e51d83167470d">&#9670;&nbsp;</a></span>addSubfile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str addSubfile </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>subfile_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a>&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compression_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a file on disk as a subfile to the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. The file named by filename will be read and added to the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> at the next call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>. If there already exists a subfile with the indicated name, it is replaced without examining its contents (but see also update_subfile). </p>
<p>Filename::set_binary() or set_text() must have been called previously to specify the nature of the source file. If set_text() was called, the text flag will be set on the subfile.</p>
<p>Returns the subfile name on success (it might have been modified slightly), or empty string on failure. </p>

</div>
</div>
<a id="a1e3b21ce0f496db5dff24349fef47df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3b21ce0f496db5dff24349fef47df9">&#9670;&nbsp;</a></span>addSubfile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str addSubfile </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>subfile_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Istream.html">Istream</a>&#160;</td>
          <td class="paramname"><em>subfile_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compression_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a file from a stream as a subfile to the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. The indicated istream will be read and its contents added to the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> at the next call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>. The file will be added as a binary subfile. </p>
<p>Note that the istream must remain untouched and unused by any other code until <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a> is called. At that time, the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> will read the entire contents of the istream from the current file position to the end of the file. Subsequently, the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> will <em>not</em> close or delete the istream. It is the caller's responsibility to ensure that the istream pointer does not destruct during the lifetime of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>.</p>
<p>Returns the subfile name on success (it might have been modified slightly), or empty string on failure. </p>

</div>
</div>
<a id="aa69c8bf1f1dcf4e72552efff1fe3e87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69c8bf1f1dcf4e72552efff1fe3e87e">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> if it is open. All changes are flushed to disk, and the file becomes invalid for further operations until the next call to open(). </p>

</div>
</div>
<a id="abc10612dc39c975154ed5d39e308fcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc10612dc39c975154ed5d39e308fcab">&#9670;&nbsp;</a></span>closeReadSubfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static closeReadSubfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Istream.html">Istream</a>&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes a file opened by a previous call to open_read_subfile(). This really just deletes the istream pointer, but it is recommended to use this interface instead of deleting it explicitly, to help work around compiler issues. </p>

</div>
</div>
<a id="ad8609eb0933ec3cc7e3b3e2a552294ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8609eb0933ec3cc7e3b3e2a552294ee">&#9670;&nbsp;</a></span>compareSubfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool compareSubfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a>&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a byte-for-byte comparison of the indicated file on disk with the nth subfile. Returns true if the files are equivalent, or false if they are different (or the file is missing). </p>
<p>If Filename::set_binary() or set_text() has already been called, it specifies the nature of the source file. If this is different from the text flag of the subfile, the comparison will always return false. If this has not been specified, it will be set from the text flag of the subfile. </p>

</div>
</div>
<a id="a046aee320b6f9220274390560990e91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046aee320b6f9220274390560990e91b">&#9670;&nbsp;</a></span>extractSubfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool extractSubfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a>&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the nth subfile into a file with the given name. </p>

</div>
</div>
<a id="af31a4d17324a9def0b0edd4b84f831b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31a4d17324a9def0b0edd4b84f831b2">&#9670;&nbsp;</a></span>extractSubfileTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool extractSubfileTo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a>&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the nth subfile to the indicated ostream. </p>

</div>
</div>
<a id="ac928dbf50c91c6b7ad669a3d901a287f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac928dbf50c91c6b7ad669a3d901a287f">&#9670;&nbsp;</a></span>findSubfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int findSubfile </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>subfile_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the subfile with the indicated name, or -1 if the named subfile is not within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. </p>

</div>
</div>
<a id="a829df08537ae314dc10a47681fbbfde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829df08537ae314dc10a47681fbbfde3">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes all contents of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> to disk. Until <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a> is called, add_subfile() and remove_subfile() do not actually do anything to disk. At this point, all of the recently-added subfiles are read and their contents are added to the end of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>, and the recently-removed subfiles are marked gone from the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. </p>
<p>This may result in a suboptimal index. To guarantee that the index is written at the beginning of the file, call <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#af69b8f30c638a2feb8f02e4f3d173884" title="Forces a complete rewrite of the Multifile and all of its contents, so that its index will appear at ...">repack()</a> instead of <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>.</p>
<p>It is not necessary to call <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a> explicitly unless you are concerned about reading the recently-added subfiles immediately.</p>
<p>Returns true on success, false on failure. </p>

</div>
</div>
<a id="ada1a9d3f36b2a86daac4849b6d8b8b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1a9d3f36b2a86daac4849b6d8b8b7b">&#9670;&nbsp;</a></span>getEncryptionAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str getEncryptionAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the encryption algorithm that was specified by set_encryption_algorithm(). </p>

</div>
</div>
<a id="a1a77fb816998ec3fe8b32fbe70b692b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a77fb816998ec3fe8b32fbe70b692b7">&#9670;&nbsp;</a></span>getEncryptionFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getEncryptionFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the flag indicating whether subsequently-added subfiles should be encrypted before writing them to the multifile. See set_encryption_flag(). </p>

</div>
</div>
<a id="abd2282692d36dd91391634c53cfc01a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2282692d36dd91391634c53cfc01a2">&#9670;&nbsp;</a></span>getEncryptionIterationCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getEncryptionIterationCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value that was specified by set_encryption_iteration_count(). </p>

</div>
</div>
<a id="a2f9687ec1df6c32838af641671129271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9687ec1df6c32838af641671129271">&#9670;&nbsp;</a></span>getEncryptionKeyLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getEncryptionKeyLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the encryption key length, in bits, that was specified by set_encryption_key_length(). </p>

</div>
</div>
<a id="a5a0d1e6fabfa2a68b820fb14c0592d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0d1e6fabfa2a68b820fb14c0592d06">&#9670;&nbsp;</a></span>getEncryptionPassword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str getEncryptionPassword </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the password that will be used to encrypt subfiles subsequently added to the multifile. See set_encryption_password(). </p>

</div>
</div>
<a id="a9a56ef211c6852cd3aaeb17e558c4885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a56ef211c6852cd3aaeb17e558c4885">&#9670;&nbsp;</a></span>getHeaderPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str getHeaderPrefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string that preceded the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> header on the file, if any. See set_header_prefix(). </p>

</div>
</div>
<a id="a0ce2a3f5c6a12aad4845802f036cdc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce2a3f5c6a12aad4845802f036cdc75">&#9670;&nbsp;</a></span>getIndexEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Streampos getIndexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first byte that is guaranteed to follow any index byte already written to disk in the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. </p>
<p>This number is largely meaningless in many cases, but if needs_repack() is false, and the file is flushed, this will indicate the number of bytes in the header</p><ul>
<li>index. Everything at this byte position and later will be actual data. </li>
</ul>

</div>
</div>
<a id="a2f75f2c14efc57231ffa1425f4eb7380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f75f2c14efc57231ffa1425f4eb7380">&#9670;&nbsp;</a></span>getMagicNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static str getMagicNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string with the first n bytes written to a <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>, to identify it as a <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. </p>

</div>
</div>
<a id="aab1181557963644bf130bf3f64010bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1181557963644bf130bf3f64010bce">&#9670;&nbsp;</a></span>getMultifileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a> getMultifileName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the filename of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>, if it is available. </p>

</div>
</div>
<a id="a8737e1495f73b9ef938a0324df16f02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8737e1495f73b9ef938a0324df16f02b">&#9670;&nbsp;</a></span>getNumSubfiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumSubfiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of subfiles within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. The subfiles may be accessed in alphabetical order by iterating through [0 .. get_num_subfiles()). </p>

</div>
</div>
<a id="a62afb67c0a8a5350a60d4d0f60acfcdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62afb67c0a8a5350a60d4d0f60acfcdb">&#9670;&nbsp;</a></span>getRecordTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getRecordTimestamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the flag indicating whether timestamps should be recorded within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> or not. See set_record_timestamp(). </p>

</div>
</div>
<a id="a240c1c043ab787abe65f4617ff52d014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240c1c043ab787abe65f4617ff52d014">&#9670;&nbsp;</a></span>getScaleFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getScaleFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the internal scale factor for this <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. See set_scale_factor(). </p>

</div>
</div>
<a id="a39d5a31ec30354b4fa53dbe0bf19d92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d5a31ec30354b4fa53dbe0bf19d92c">&#9670;&nbsp;</a></span>getSubfileInternalLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getSubfileInternalLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes the indicated subfile consumes within the archive. For compressed subfiles, this will generally be smaller than get_subfile_length(); for encrypted (but noncompressed) subfiles, it may be slightly different, for noncompressed and nonencrypted subfiles, it will be equal. </p>

</div>
</div>
<a id="a2e920f136d9845f5693478c9997a5529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e920f136d9845f5693478c9997a5529">&#9670;&nbsp;</a></span>getSubfileInternalStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Streampos getSubfileInternalStart </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the starting byte position within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> at which the indicated subfile begins. This may be used, with get_subfile_internal_length(), for low-level access to the subfile, but usually it is better to use open_read_subfile() instead (which automatically decrypts and/or uncompresses the subfile data). </p>

</div>
</div>
<a id="a3f89195b1f30c6b63d3c6776b03275dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f89195b1f30c6b63d3c6776b03275dd">&#9670;&nbsp;</a></span>getSubfileLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getSubfileLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uncompressed data length of the nth subfile. This might return 0 if the subfile has recently been added and <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a> has not yet been called. </p>

</div>
</div>
<a id="a102dd8f674097acf8c2c4d2acf9aa732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102dd8f674097acf8c2c4d2acf9aa732">&#9670;&nbsp;</a></span>getSubfileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str getSubfileName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the nth subfile. </p>

</div>
</div>
<a id="a1242891318dd73ed8b507a9111f69a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1242891318dd73ed8b507a9111f69a10">&#9670;&nbsp;</a></span>getSubfileNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list getSubfileNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9be6f15bbe06540d8fa278eccae1666c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be6f15bbe06540d8fa278eccae1666c">&#9670;&nbsp;</a></span>getSubfileTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t getSubfileTimestamp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the modification time of the nth subfile. If this is called on an older .mf file, which did not store individual timestamps in the file (or if get_record_timestamp() is false), this will return the modification time of the overall multifile. </p>

</div>
</div>
<a id="a18097ef35cac00ba6eea85b262b7871f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18097ef35cac00ba6eea85b262b7871f">&#9670;&nbsp;</a></span>getTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t getTimestamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the modification timestamp of the overall <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. This indicates the most recent date at which subfiles were added or removed from the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. Note that it is logically possible for an individual subfile to have a more recent timestamp than the overall timestamp. </p>

</div>
</div>
<a id="aeeb753c8fd60865597eeafa6db549588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb753c8fd60865597eeafa6db549588">&#9670;&nbsp;</a></span>hasDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hasDirectory </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>subfile_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the indicated subfile name is the directory prefix to one or more files within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. That is, the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> contains at least one file named "subfile_name/...". </p>

</div>
</div>
<a id="a184aefb677f70bb13cec310957abdb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184aefb677f70bb13cec310957abdb03">&#9670;&nbsp;</a></span>isReadValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isReadValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> has been opened for read mode and there have been no errors, and individual Subfile contents may be extracted. </p>

</div>
</div>
<a id="acd5e475c5655406d993a32f667b63445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5e475c5655406d993a32f667b63445">&#9670;&nbsp;</a></span>isSubfileCompressed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSubfileCompressed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the indicated subfile has been compressed when stored within the archive, false otherwise. </p>

</div>
</div>
<a id="a88b5b92e4fb94ee0c24c2854b38fb681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b5b92e4fb94ee0c24c2854b38fb681">&#9670;&nbsp;</a></span>isSubfileEncrypted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSubfileEncrypted </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the indicated subfile has been encrypted when stored within the archive, false otherwise. </p>

</div>
</div>
<a id="a2394db5675b118d558b72d70c166b3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2394db5675b118d558b72d70c166b3f8">&#9670;&nbsp;</a></span>isSubfileText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSubfileText </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the indicated subfile represents text data, or false if it represents binary data. If the file is text data, it may have been processed by end-of-line conversion when it was added. (But the actual bits in the multifile will represent the standard Unix end-of-line convention, e.g. <br />
 instead of <br />
.) </p>

</div>
</div>
<a id="afd4de0e02a3db53e1e9a938f3e9eef70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4de0e02a3db53e1e9a938f3e9eef70">&#9670;&nbsp;</a></span>isWriteValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isWriteValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> has been opened for write mode and there have been no errors, and Subfiles may be added or removed from the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. </p>

</div>
</div>
<a id="ac0601a5e4cc80fbfc626db580f9814c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0601a5e4cc80fbfc626db580f9814c7">&#9670;&nbsp;</a></span>ls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a>&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shows a list of all subfiles within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. </p>

</div>
</div>
<a id="a6b88858bf7f30aa7906b48716c3b6b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b88858bf7f30aa7906b48716c3b6b71">&#9670;&nbsp;</a></span>needsRepack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool needsRepack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> index is suboptimal and should be repacked. Call <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#af69b8f30c638a2feb8f02e4f3d173884" title="Forces a complete rewrite of the Multifile and all of its contents, so that its index will appear at ...">repack()</a> to achieve this. </p>

</div>
</div>
<a id="ad5f4de0106da336821310fba018b1ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f4de0106da336821310fba018b1ef3">&#9670;&nbsp;</a></span>openRead() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a>&#160;</td>
          <td class="paramname"><em>multifile_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Streampos&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the named <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> on disk for reading. The <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> index is read in, and the list of subfiles becomes available; individual subfiles may then be extracted or read, but the list of subfiles may not be modified. </p>
<p>Also see the version of open_read() which accepts an istream. Returns true on success, false on failure. </p>

</div>
</div>
<a id="a671ac11cf945293b3e7004784fde5c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671ac11cf945293b3e7004784fde5c58">&#9670;&nbsp;</a></span>openRead() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1IStreamWrapper.html">IStreamWrapper</a>&#160;</td>
          <td class="paramname"><em>multifile_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>owns_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Streampos&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an anonymous <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> for reading using an istream. There must be seek functionality via seekg() and tellg() on the istream. </p>
<p>If owns_pointer is true, then the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> assumes ownership of the stream pointer and will delete it when the multifile is closed, including if this function returns false. </p>

</div>
</div>
<a id="ab1c1ffeae6d0b2babf1ba7d3017fb9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c1ffeae6d0b2babf1ba7d3017fb9ec">&#9670;&nbsp;</a></span>openReadSubfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1Istream.html">Istream</a> openReadSubfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an istream that may be used to read the indicated subfile. You may seek() within this istream to your heart's content; even though it will be a reference to the already-opened pfstream of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> itself, byte 0 appears to be the beginning of the subfile and EOF appears to be the end of the subfile. </p>
<p>The returned istream will have been allocated via new; you should pass the pointer to close_read_subfile() when you are finished with it to delete it and release its resources.</p>
<p>Any future calls to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#af69b8f30c638a2feb8f02e4f3d173884" title="Forces a complete rewrite of the Multifile and all of its contents, so that its index will appear at ...">repack()</a> or <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#aa69c8bf1f1dcf4e72552efff1fe3e87e" title="Closes the Multifile if it is open. All changes are flushed to disk, and the file becomes invalid for...">close()</a> (or the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> destructor) will invalidate all currently open subfile pointers.</p>
<p>The return value will be NULL if the stream cannot be opened for some reason. </p>

</div>
</div>
<a id="a4b3ef281de52a50930d83c71ac47eb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3ef281de52a50930d83c71ac47eb07">&#9670;&nbsp;</a></span>openReadWrite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openReadWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a>&#160;</td>
          <td class="paramname"><em>multifile_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the named <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> on disk for reading and writing. If there already exists a file by that name, its index is read. Subfiles may be added or removed, and the resulting changes will be written to the named file. </p>
<p>Also see the version of open_read_write() which accepts an iostream. Returns true on success, false on failure. </p>

</div>
</div>
<a id="a99cdf93795d916c68181f5149b074809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cdf93795d916c68181f5149b074809">&#9670;&nbsp;</a></span>openReadWrite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openReadWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Iostream.html">Iostream</a>&#160;</td>
          <td class="paramname"><em>multifile_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>owns_pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an anonymous <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> for reading and writing using an iostream. There must be seek functionality via seekg()/seekp() and tellg()/tellp() on the iostream. </p>
<p>If owns_pointer is true, then the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> assumes ownership of the stream pointer and will delete it when the multifile is closed, including if this function returns false. </p>

</div>
</div>
<a id="a3f1dcd194644998f1d0554c05e5ea0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1dcd194644998f1d0554c05e5ea0d0">&#9670;&nbsp;</a></span>openWrite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a>&#160;</td>
          <td class="paramname"><em>multifile_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the named <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> on disk for writing. If there already exists a file by that name, it is truncated. The <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> is then prepared for accepting a brand new set of subfiles, which will be written to the indicated filename. Individual subfiles may not be extracted or read. </p>
<p>Also see the version of open_write() which accepts an ostream. Returns true on success, false on failure. </p>

</div>
</div>
<a id="a683068c03489224503e01f3326eb55b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683068c03489224503e01f3326eb55b4">&#9670;&nbsp;</a></span>openWrite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a>&#160;</td>
          <td class="paramname"><em>multifile_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>owns_pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an anonymous <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> for writing using an ostream. There must be seek functionality via seekp() and tellp() on the pstream. </p>
<p>If owns_pointer is true, then the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> assumes ownership of the stream pointer and will delete it when the multifile is closed, including if this function returns false. </p>

</div>
</div>
<a id="abe34a3beba58bdae238301d02aac87f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe34a3beba58bdae238301d02aac87f0">&#9670;&nbsp;</a></span>output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a>&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39650a303a16e0fd33122e6d53dbc942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39650a303a16e0fd33122e6d53dbc942">&#9670;&nbsp;</a></span>readSubfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str readSubfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string that contains the entire contents of the indicated subfile. </p>

</div>
</div>
<a id="a3cd58c550dc8eed03aeb7e6d1873f118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd58c550dc8eed03aeb7e6d1873f118">&#9670;&nbsp;</a></span>removeSubfile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">removeSubfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth subfile from the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. This will cause all subsequent index numbers to decrease by one. The file will not actually be removed from the disk until the next call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>. </p>
<p>Note that this does not actually remove the data from the indicated subfile; it simply removes it from the index. The <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> will not be reduced in size after this operation, until the next call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#af69b8f30c638a2feb8f02e4f3d173884" title="Forces a complete rewrite of the Multifile and all of its contents, so that its index will appear at ...">repack()</a>. </p>

</div>
</div>
<a id="a0b4b82933b6d6d30d078291c151b8b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4b82933b6d6d30d078291c151b8b19">&#9670;&nbsp;</a></span>removeSubfile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool removeSubfile </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>subfile_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the named subfile from the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>, if it exists; returns true if successfully removed, or false if it did not exist in the first place. The file will not actually be removed from the disk until the next call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>. </p>
<p>Note that this does not actually remove the data from the indicated subfile; it simply removes it from the index. The <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> will not be reduced in size after this operation, until the next call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#af69b8f30c638a2feb8f02e4f3d173884" title="Forces a complete rewrite of the Multifile and all of its contents, so that its index will appear at ...">repack()</a>. </p>

</div>
</div>
<a id="af69b8f30c638a2feb8f02e4f3d173884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69b8f30c638a2feb8f02e4f3d173884">&#9670;&nbsp;</a></span>repack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool repack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces a complete rewrite of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> and all of its contents, so that its index will appear at the beginning of the file with all of the subfiles listed in alphabetical order. This is considered optimal for reading, and is the standard configuration; but it is not essential to do this. </p>
<p>It is only valid to call this if the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> was opened using open_read_write() and an explicit filename, rather than an iostream. Also, we must have write permission to the directory containing the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>.</p>
<p>Returns true on success, false on failure. </p>

</div>
</div>
<a id="acbbe1e2abc9939930434f7961e07c614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbe1e2abc9939930434f7961e07c614">&#9670;&nbsp;</a></span>scanDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool scanDirectory </td>
          <td>(</td>
          <td class="paramtype">VectorString&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>subfile_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Considers subfile_name to be the name of a subdirectory within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>, but not a file itself; fills the given vector up with the sorted list of subdirectories or files within the named directory. </p>
<p>Note that directories do not exist explicitly within a <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>; this just checks for the existence of files with the given initial prefix.</p>
<p>Returns true if successful, false otherwise. </p>

</div>
</div>
<a id="a3622dbfa30e843756040ec6129022680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3622dbfa30e843756040ec6129022680">&#9670;&nbsp;</a></span>setEncryptionAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setEncryptionAlgorithm </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>encryption_algorithm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the encryption algorithm that should be used for future calls to add_subfile(). The default is whatever is specified by the encryption-algorithm config variable. The complete set of available algorithms is defined by the current version of OpenSSL. </p>
<p>If an invalid algorithm is specified, there is no immediate error return code, but <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a> will fail and the file will be invalid.</p>
<p>It is possible to apply a different encryption algorithm to different files, and unlike the password, this does not interfere with mounting the multifile via VFS. Changing this value may cause an implicit call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>. </p>

</div>
</div>
<a id="ac76fb9378517ed64b59e1285c1db2757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76fb9378517ed64b59e1285c1db2757">&#9670;&nbsp;</a></span>setEncryptionFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setEncryptionFlag </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the flag indicating whether subsequently-added subfiles should be encrypted before writing them to the multifile. If true, subfiles will be encrypted; if false (the default), they will be written without encryption. </p>
<p>When true, subfiles will be encrypted with the password specified by set_encryption_password(). It is possible to apply a different password to different files, but the resulting file can't be mounted via VFS. </p>

</div>
</div>
<a id="a49764fa6f31f3006de7ae158f687856d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49764fa6f31f3006de7ae158f687856d">&#9670;&nbsp;</a></span>setEncryptionIterationCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setEncryptionIterationCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>encryption_iteration_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the number of times to repeatedly hash the key before writing it to the stream in future calls to add_subfile(). Its purpose is to make it computationally more expensive for an attacker to search the key space exhaustively. This should be a multiple of 1,000 and should not exceed about 65 million; the value 0 indicates just one application of the hashing algorithm. </p>
<p>The default is whatever is specified by the multifile-encryption-iteration-count config variable.</p>
<p>It is possible to apply a different iteration count to different files, and unlike the password, this does not interfere with mounting the multifile via VFS. Changing this value causes an implicit call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>. </p>

</div>
</div>
<a id="a758ecbcbbca7479611d2e2e4803b4f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758ecbcbbca7479611d2e2e4803b4f01">&#9670;&nbsp;</a></span>setEncryptionKeyLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setEncryptionKeyLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>encryption_key_length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the length of the key, in bits, that should be used to encrypt the stream in future calls to add_subfile(). The default is whatever is specified by the encryption-key-length config variable. </p>
<p>If an invalid key_length for the chosen algorithm is specified, there is no immediate error return code, but <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a> will fail and the file will be invalid.</p>
<p>It is possible to apply a different key length to different files, and unlike the password, this does not interfere with mounting the multifile via VFS. Changing this value may cause an implicit call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>. </p>

</div>
</div>
<a id="ab52975417e489873ef67b9d604b7709c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52975417e489873ef67b9d604b7709c">&#9670;&nbsp;</a></span>setEncryptionPassword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setEncryptionPassword </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>encryption_password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the password that will be used to encrypt subfiles subsequently added to the multifile, if the encryption flag is also set true (see set_encryption_flag()). </p>
<p>It is possible to apply a different password to different files, but the resulting file can't be mounted via VFS. Changing this value may cause an implicit call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#a829df08537ae314dc10a47681fbbfde3" title="Writes all contents of the Multifile to disk. Until flush() is called, add_subfile() and remove_subfi...">flush()</a>. </p>

</div>
</div>
<a id="aac5787f4065b9afe542943ec115a336c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5787f4065b9afe542943ec115a336c">&#9670;&nbsp;</a></span>setHeaderPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setHeaderPrefix </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>header_prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the string which is written to the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> before the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> header. This string must begin with a hash mark and end with a newline character; and if it includes embedded newline characters, each one must be followed by a hash mark. If these conditions are not initially true, the string will be modified as necessary to make it so. </p>
<p>This is primarily useful as a simple hack to allow p3d applications to be run directly from the command line on Unix-like systems.</p>
<p>The return value is true if successful, or false on failure (for instance, because the header prefix violates the above rules). </p>

</div>
</div>
<a id="ad69da1a34a214dc6e07f7d3659a1497e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69da1a34a214dc6e07f7d3659a1497e">&#9670;&nbsp;</a></span>setMultifileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setMultifileName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a>&#160;</td>
          <td class="paramname"><em>multifile_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the filename of the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. This is primarily used for documentation purposes only; changing this name does not open the indicated file. See open_read() or open_write() for that. </p>

</div>
</div>
<a id="a02889eade453b4f1513cc719aa2c0509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02889eade453b4f1513cc719aa2c0509">&#9670;&nbsp;</a></span>setRecordTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setRecordTimestamp </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>record_timestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the flag indicating whether timestamps should be recorded within the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> or not. The default is true, indicating the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> will record timestamps for the overall file and also for each subfile. </p>
<p>If this is false, the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> will not record timestamps internally. In this case, the return value from get_timestamp() or get_subfile_timestamp() will be estimations.</p>
<p>You may want to set this false to minimize the bitwise difference between independently-generated Multifiles. </p>

</div>
</div>
<a id="ac87ff2f95d211c79584b22638bf4fe1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87ff2f95d211c79584b22638bf4fe1e">&#9670;&nbsp;</a></span>setScaleFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setScaleFactor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>scale_factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the internal scale factor for this <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a>. </p>
<p>This is normally 1, but it may be set to any arbitrary value (greater than zero) to support <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> archives that exceed 4GB, if necessary. (Individual subfiles may still not exceed 4GB.)</p>
<p>All addresses within the file are rounded up to the next multiple of _scale_factor, and zeros are written to the file to fill the resulting gaps. Then the address is divided by _scale_factor and written out as a 32-bit integer. Thus, setting a scale factor of 2 supports up to 8GB files, 3 supports 12GB files, etc.</p>
<p>Calling this function on an already-existing <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> will have no immediate effect until a future call to <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#af69b8f30c638a2feb8f02e4f3d173884" title="Forces a complete rewrite of the Multifile and all of its contents, so that its index will appear at ...">repack()</a> or <a class="el" href="classpanda3d_1_1core_1_1Multifile.html#aa69c8bf1f1dcf4e72552efff1fe3e87e" title="Closes the Multifile if it is open. All changes are flushed to disk, and the file becomes invalid for...">close()</a> (or until the <a class="el" href="classpanda3d_1_1core_1_1Multifile.html" title="A file that contains a set of files. ">Multifile</a> is destructed). </p>

</div>
</div>
<a id="a60173b28cb1502cce2816ef2493d8c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60173b28cb1502cce2816ef2493d8c4d">&#9670;&nbsp;</a></span>updateSubfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str updateSubfile </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>subfile_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a>&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compression_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a file on disk to the subfile. If a subfile already exists with the same name, its contents are compared byte-for-byte to the disk file, and it is replaced only if it is different; otherwise, the multifile is left unchanged. </p>
<p>Filename::set_binary() or set_text() must have been called previously to specify the nature of the source file. If set_text() was called, the text flag will be set on the subfile. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 18 2017 01:46:57 for Panda3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
